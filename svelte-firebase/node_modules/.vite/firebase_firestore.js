import {
  Component,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-5SAEOKTG.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (var c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  var d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (var f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    var c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (var e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  var b = a.length;
  if (0 < b) {
    var c = Array(b);
    for (var d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (var d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  var b = {};
  for (var c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  var c, d;
  for (var e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (var f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    var a = 0;
    var b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (var h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  var b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = function() {
  function ub2() {
    this.h = this.g = null;
  }
  ub2.prototype.add = function(a, b) {
    var c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  };
  return ub2;
}();
var vb = new (function() {
  function class_2(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  class_2.prototype.get = function() {
    var a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  };
  return class_2;
}())(function() {
  return new wb();
}, function(a) {
  return a.reset();
});
var wb = function() {
  function wb2() {
    this.next = this.g = this.h = null;
  }
  wb2.prototype.set = function(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  };
  wb2.prototype.reset = function() {
    this.next = this.g = this.h = null;
  };
  return wb2;
}();
function yb(a) {
  l.setTimeout(function() {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(function() {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  var b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = function(_super) {
  __extends(Ib2, _super);
  function Ib2(a, b) {
    var _this = _super.call(this) || this;
    _this.m = a;
    _this.j = b;
    _this.h = null;
    _this.i = false;
    _this.g = null;
    return _this;
  }
  Ib2.prototype.l = function(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  };
  Ib2.prototype.M = function() {
    _super.prototype.M.call(this);
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  };
  return Ib2;
}(v);
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  var b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  var b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  var b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        var r = O(this.g);
        var b = this.g.Da();
        var G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r2) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  var d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  var a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m2) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m2) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          var m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              var r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              var G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              var Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              var ca2 = a.g;
              if (ca2) {
                var Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  var xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m2) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = function() {
  function fd2(a, b) {
    this.h = a;
    this.g = b;
  }
  return fd2;
}();
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  var e_1, _a2;
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    try {
      for (var _b = __values(this.g.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var a = _c2.value;
        a.cancel();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c2 && !_c2.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    this.g.clear();
  }
};
function jd(a) {
  var e_2, _a2;
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    var b = a.i;
    try {
      for (var _b = __values(a.g.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var c = _c2.value;
        b = b.concat(c.D);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c2 && !_c2.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  var d = c || "";
  try {
    Kc(a, function(e, f) {
      var h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  var c = new Mb();
  if (l.Image) {
    var d_1 = new Image();
    d_1.onload = ja(od, c, d_1, "TestLoadImage: loaded", true, b);
    d_1.onerror = ja(od, c, d_1, "TestLoadImage: error", false, b);
    d_1.onabort = ja(od, c, d_1, "TestLoadImage: abort", false, b);
    d_1.ontimeout = ja(od, c, d_1, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d_1.ontimeout)
        d_1.ontimeout();
    }, 1e4);
    d_1.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  var b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  var a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  var e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        var n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    var c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  var b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        var e = new M(this, this.h, a, void 0);
        var f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  var d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    var f = -1;
    for (; ; ) {
      var h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      var n = true;
      for (var u = 0; u < c; u++) {
        var m = e[u].h;
        var r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  var c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  var d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    var e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e2, f) {
    R(d, f, e2);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (var c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = Wb;
var EventType = Xb;
var Event = H;
var Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = pd;
var WebChannel = $b;
var XhrIo = X;

// node_modules/@firebase/firestore/dist/exp/index.browser.esm2017.js
var V2 = "8.7.1";
var S2 = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.t(t3), this.i = (t3) => e.writeSequenceNumber(t3));
  }
  t(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.i && this.i(t2), t2;
  }
};
S2.o = -1;
var D2 = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var C2 = class extends Error {
  constructor(t2, e) {
    super(e), this.code = t2, this.message = e, this.name = "FirebaseError", this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var N2 = new Logger("@firebase/firestore");
function x2() {
  return N2.logLevel;
}
function k2(t2) {
  N2.setLogLevel(t2);
}
function $(t2, ...e) {
  if (N2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(M2);
    N2.debug(`Firestore (${V2}): ${t2}`, ...n);
  }
}
function O2(t2, ...e) {
  if (N2.logLevel <= LogLevel.ERROR) {
    const n = e.map(M2);
    N2.error(`Firestore (${V2}): ${t2}`, ...n);
  }
}
function F2(t2, ...e) {
  if (N2.logLevel <= LogLevel.WARN) {
    const n = e.map(M2);
    N2.warn(`Firestore (${V2}): ${t2}`, ...n);
  }
}
function M2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function L2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${V2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw O2(e), new Error(e);
}
function B2(t2, e) {
  t2 || L2();
}
function U2(t2, e) {
  return t2;
}
function q2(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
var K2 = class {
  static u() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = q2(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function j(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function Q2(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function W2(t2) {
  return t2 + "\0";
}
var G = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new C2(D2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new C2(D2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new C2(D2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new C2(D2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return G.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return G.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new G(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? j(this.nanoseconds, t2.nanoseconds) : j(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var z2 = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new z2(t2);
  }
  static min() {
    return new z2(new G(0, 0));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function H2(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function J2(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function Y2(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var X2 = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && L2(), n === void 0 ? n = t2.length - e : n > t2.length - e && L2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return X2.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof X2 ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var Z2 = class extends X2 {
  construct(t2, e, n) {
    return new Z2(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new C2(D2.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new Z2(e);
  }
  static emptyPath() {
    return new Z2([]);
  }
};
var tt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var et = class extends X2 {
  construct(t2, e, n) {
    return new et(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return tt.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), et.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new et(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new C2(D2.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new C2(D2.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new C2(D2.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new C2(D2.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new et(e);
  }
  static emptyPath() {
    return new et([]);
  }
};
var nt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(et.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return Q2(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
var st = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new st(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new st(e);
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return j(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
st.EMPTY_BYTE_STRING = new st("");
var it = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function rt(t2) {
  if (B2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = it.exec(t2);
    if (B2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: ot(t2.seconds),
    nanos: ot(t2.nanos)
  };
}
function ot(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function ct(t2) {
  return typeof t2 == "string" ? st.fromBase64String(t2) : st.fromUint8Array(t2);
}
function ut(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function at(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return ut(e) ? at(e) : e;
}
function ht(t2) {
  const e = rt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new G(e.seconds, e.nanos);
}
function lt(t2) {
  return t2 == null;
}
function ft(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function dt(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !ft(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var wt = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new wt(Z2.fromString(t2));
  }
  static fromName(t2) {
    return new wt(Z2.fromString(t2).popFirst(5));
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  isEqual(t2) {
    return t2 !== null && Z2.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return Z2.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new wt(new Z2(t2.slice()));
  }
};
function _t(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? ut(t2) ? 4 : 10 : L2();
}
function mt(t2, e) {
  const n = _t(t2);
  if (n !== _t(e))
    return false;
  switch (n) {
    case 0:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return ht(t2).isEqual(ht(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = rt(t3.timestampValue), s = rt(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return ct(t3.bytesValue).isEqual(ct(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return ot(t3.geoPointValue.latitude) === ot(e2.geoPointValue.latitude) && ot(t3.geoPointValue.longitude) === ot(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return ot(t3.integerValue) === ot(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = ot(t3.doubleValue), s = ot(e2.doubleValue);
          return n2 === s ? ft(n2) === ft(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return Q2(t2.arrayValue.values || [], e.arrayValue.values || [], mt);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (H2(n2) !== H2(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !mt(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return L2();
  }
}
function gt(t2, e) {
  return (t2.values || []).find((t3) => mt(t3, e)) !== void 0;
}
function yt(t2, e) {
  const n = _t(t2), s = _t(e);
  if (n !== s)
    return j(n, s);
  switch (n) {
    case 0:
      return 0;
    case 1:
      return j(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = ot(t3.integerValue || t3.doubleValue), s2 = ot(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return pt(t2.timestampValue, e.timestampValue);
    case 4:
      return pt(ht(t2), ht(e));
    case 5:
      return j(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = ct(t3), s2 = ct(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = j(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return j(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = j(ot(t3.latitude), ot(e2.latitude));
        if (n2 !== 0)
          return n2;
        return j(ot(t3.longitude), ot(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = yt(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return j(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = j(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = yt(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return j(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw L2();
  }
}
function pt(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return j(t2, e);
  const n = rt(t2), s = rt(e), i = j(n.seconds, s.seconds);
  return i !== 0 ? i : j(n.nanos, s.nanos);
}
function Et(t2) {
  return Tt(t2);
}
function Tt(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = rt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? ct(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, wt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += Tt(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${Tt(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : L2();
  var e, n;
}
function It(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function At(t2) {
  return !!t2 && "integerValue" in t2;
}
function Rt(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Pt(t2) {
  return !!t2 && "nullValue" in t2;
}
function bt(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function vt(t2) {
  return !!t2 && "mapValue" in t2;
}
function Vt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return J2(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = Vt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Vt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
var St = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new St({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !vt(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Vt(e);
  }
  setAll(t2) {
    let e = et.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = Vt(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    vt(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return mt(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      vt(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    J2(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new St(Vt(this.value));
  }
};
function Dt(t2) {
  const e = [];
  return J2(t2.fields, (t3, n) => {
    const s = new et([t3]);
    if (vt(n)) {
      const t4 = Dt(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new nt(e);
}
var Ct = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.documentType = e, this.version = n, this.data = s, this.documentState = i;
  }
  static newInvalidDocument(t2) {
    return new Ct(t2, 0, z2.min(), St.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new Ct(t2, 1, e, n, 0);
  }
  static newNoDocument(t2, e) {
    return new Ct(t2, 2, e, St.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new Ct(t2, 3, e, St.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = St.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = St.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof Ct && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  clone() {
    return new Ct(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var Nt = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.h = null;
  }
};
function xt(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new Nt(t2, e, n, s, i, r, o);
}
function kt(t2) {
  const e = U2(t2);
  if (e.h === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => Lt(t4)).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), lt(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += Ht(e.startAt)), e.endAt && (t3 += "|ub:", t3 += Ht(e.endAt)), e.h = t3;
  }
  return e.h;
}
function $t(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${Et(e2.value)}`;
    var e2;
  }).join(", ")}]`), lt(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: " + Ht(t2.startAt)), t2.endAt && (e += ", endAt: " + Ht(t2.endAt)), `Target(${e})`;
}
function Ot(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!Yt(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !mt(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!Zt(t2.startAt, e.startAt) && Zt(t2.endAt, e.endAt)));
}
function Ft(t2) {
  return wt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
var Mt = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.l(t2, e, n) : new Bt(t2, e, n) : e === "array-contains" ? new jt(t2, n) : e === "in" ? new Qt(t2, n) : e === "not-in" ? new Wt(t2, n) : e === "array-contains-any" ? new Gt(t2, n) : new Mt(t2, e, n);
  }
  static l(t2, e, n) {
    return e === "in" ? new Ut(t2, n) : new qt(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.m(yt(e, this.value)) : e !== null && _t(this.value) === _t(e) && this.m(yt(e, this.value));
  }
  m(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return L2();
    }
  }
  g() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
function Lt(t2) {
  return t2.field.canonicalString() + t2.op.toString() + Et(t2.value);
}
var Bt = class extends Mt {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = wt.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = wt.comparator(t2.key, this.key);
    return this.m(e);
  }
};
var Ut = class extends Mt {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = Kt("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var qt = class extends Mt {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = Kt("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function Kt(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => wt.fromName(t3.referenceValue));
}
var jt = class extends Mt {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return Rt(e) && gt(e.arrayValue, this.value);
  }
};
var Qt = class extends Mt {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && gt(this.value.arrayValue, e);
  }
};
var Wt = class extends Mt {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (gt(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !gt(this.value.arrayValue, e);
  }
};
var Gt = class extends Mt {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!Rt(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => gt(this.value.arrayValue, t3));
  }
};
var zt = class {
  constructor(t2, e) {
    this.position = t2, this.before = e;
  }
};
function Ht(t2) {
  return `${t2.before ? "b" : "a"}:${t2.position.map((t3) => Et(t3)).join(",")}`;
}
var Jt = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function Yt(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function Xt(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = wt.comparator(wt.fromName(o.referenceValue), n.key);
    else {
      s = yt(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return t2.before ? s <= 0 : s < 0;
}
function Zt(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.before !== e.before || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!mt(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var te = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, c = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = c, this.p = null, this.T = null, this.startAt, this.endAt;
  }
};
function ee(t2, e, n, s, i, r, o, c) {
  return new te(t2, e, n, s, i, r, o, c);
}
function ne(t2) {
  return new te(t2);
}
function se(t2) {
  return !lt(t2.limit) && t2.limitType === "F";
}
function ie(t2) {
  return !lt(t2.limit) && t2.limitType === "L";
}
function re(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function oe(t2) {
  for (const e of t2.filters)
    if (e.g())
      return e.field;
  return null;
}
function ce(t2) {
  return t2.collectionGroup !== null;
}
function ue(t2) {
  const e = U2(t2);
  if (e.p === null) {
    e.p = [];
    const t3 = oe(e), n = re(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.p.push(new Jt(t3)), e.p.push(new Jt(et.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.p.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.p.push(new Jt(et.keyField(), t5));
      }
    }
  }
  return e.p;
}
function ae(t2) {
  const e = U2(t2);
  if (!e.T)
    if (e.limitType === "F")
      e.T = xt(e.path, e.collectionGroup, ue(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of ue(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new Jt(n2.field, e2));
      }
      const n = e.endAt ? new zt(e.endAt.position, !e.endAt.before) : null, s = e.startAt ? new zt(e.startAt.position, !e.startAt.before) : null;
      e.T = xt(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.T;
}
function he(t2, e, n) {
  return new te(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function le(t2, e) {
  return Ot(ae(t2), ae(e)) && t2.limitType === e.limitType;
}
function fe(t2) {
  return `${kt(ae(t2))}|lt:${t2.limitType}`;
}
function de(t2) {
  return `Query(target=${$t(ae(t2))}; limitType=${t2.limitType})`;
}
function we(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : wt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !Xt(t3.startAt, ue(t3), e2))
      return false;
    if (t3.endAt && Xt(t3.endAt, ue(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function _e(t2) {
  return (e, n) => {
    let s = false;
    for (const i of ue(t2)) {
      const t3 = me(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function me(t2, e, n) {
  const s = t2.field.isKeyField() ? wt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? yt(s2, i) : L2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return L2();
  }
}
function ge(t2, e) {
  if (t2.I) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: ft(e) ? "-0" : e
  };
}
function ye(t2) {
  return {
    integerValue: "" + t2
  };
}
function pe(t2, e) {
  return dt(e) ? ye(e) : ge(t2, e);
}
var Ee = class {
  constructor() {
    this._ = void 0;
  }
};
function Te(t2, e, n) {
  return t2 instanceof Re ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof Pe ? be(t2, e) : t2 instanceof ve ? Ve(t2, e) : function(t3, e2) {
    const n2 = Ae(t3, e2), s = De(n2) + De(t3.A);
    return At(n2) && At(t3.A) ? ye(s) : ge(t3.R, s);
  }(t2, e);
}
function Ie(t2, e, n) {
  return t2 instanceof Pe ? be(t2, e) : t2 instanceof ve ? Ve(t2, e) : n;
}
function Ae(t2, e) {
  return t2 instanceof Se ? At(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var Re = class extends Ee {
};
var Pe = class extends Ee {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function be(t2, e) {
  const n = Ce(e);
  for (const e2 of t2.elements)
    n.some((t3) => mt(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var ve = class extends Ee {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Ve(t2, e) {
  let n = Ce(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !mt(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var Se = class extends Ee {
  constructor(t2, e) {
    super(), this.R = t2, this.A = e;
  }
};
function De(t2) {
  return ot(t2.integerValue || t2.doubleValue);
}
function Ce(t2) {
  return Rt(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var Ne = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function xe(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof Pe && e2 instanceof Pe || t3 instanceof ve && e2 instanceof ve ? Q2(t3.elements, e2.elements, mt) : t3 instanceof Se && e2 instanceof Se ? mt(t3.A, e2.A) : t3 instanceof Re && e2 instanceof Re;
  }(t2.transform, e.transform);
}
var ke = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var $e = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new $e();
  }
  static exists(t2) {
    return new $e(void 0, t2);
  }
  static updateTime(t2) {
    return new $e(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function Oe(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var Fe = class {
};
function Me(t2, e, n) {
  t2 instanceof Ke ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = We(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof je ? function(t3, e2, n2) {
    if (!Oe(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = We(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(Qe(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function Le(t2, e, n) {
  t2 instanceof Ke ? function(t3, e2, n2) {
    if (!Oe(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = Ge(t3.fieldTransforms, n2, e2);
    s.setAll(i), e2.convertToFoundDocument(qe(e2), s).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof je ? function(t3, e2, n2) {
    if (!Oe(t3.precondition, e2))
      return;
    const s = Ge(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(Qe(t3)), i.setAll(s), e2.convertToFoundDocument(qe(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    Oe(t3.precondition, e2) && e2.convertToNoDocument(z2.min());
  }(t2, e);
}
function Be(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = Ae(s.transform, t3 || null);
    i != null && (n == null && (n = St.empty()), n.set(s.field, i));
  }
  return n || null;
}
function Ue(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && Q2(t3, e2, (t4, e3) => xe(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function qe(t2) {
  return t2.isFoundDocument() ? t2.version : z2.min();
}
var Ke = class extends Fe {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
};
var je = class extends Fe {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
};
function Qe(t2) {
  const e = new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function We(t2, e, n) {
  const s = new Map();
  B2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, c = e.data.field(r.field);
    s.set(r.field, Ie(o, c, n[i]));
  }
  return s;
}
function Ge(t2, e, n) {
  const s = new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, Te(t3, r, e));
  }
  return s;
}
var ze = class extends Fe {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
};
var He = class extends Fe {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
};
var Je = class {
  constructor(t2) {
    this.count = t2;
  }
};
var Ye;
var Xe;
function Ze(t2) {
  switch (t2) {
    case D2.OK:
      return L2();
    case D2.CANCELLED:
    case D2.UNKNOWN:
    case D2.DEADLINE_EXCEEDED:
    case D2.RESOURCE_EXHAUSTED:
    case D2.INTERNAL:
    case D2.UNAVAILABLE:
    case D2.UNAUTHENTICATED:
      return false;
    case D2.INVALID_ARGUMENT:
    case D2.NOT_FOUND:
    case D2.ALREADY_EXISTS:
    case D2.PERMISSION_DENIED:
    case D2.FAILED_PRECONDITION:
    case D2.ABORTED:
    case D2.OUT_OF_RANGE:
    case D2.UNIMPLEMENTED:
    case D2.DATA_LOSS:
      return true;
    default:
      return L2();
  }
}
function tn(t2) {
  if (t2 === void 0)
    return O2("GRPC error has no .code"), D2.UNKNOWN;
  switch (t2) {
    case Ye.OK:
      return D2.OK;
    case Ye.CANCELLED:
      return D2.CANCELLED;
    case Ye.UNKNOWN:
      return D2.UNKNOWN;
    case Ye.DEADLINE_EXCEEDED:
      return D2.DEADLINE_EXCEEDED;
    case Ye.RESOURCE_EXHAUSTED:
      return D2.RESOURCE_EXHAUSTED;
    case Ye.INTERNAL:
      return D2.INTERNAL;
    case Ye.UNAVAILABLE:
      return D2.UNAVAILABLE;
    case Ye.UNAUTHENTICATED:
      return D2.UNAUTHENTICATED;
    case Ye.INVALID_ARGUMENT:
      return D2.INVALID_ARGUMENT;
    case Ye.NOT_FOUND:
      return D2.NOT_FOUND;
    case Ye.ALREADY_EXISTS:
      return D2.ALREADY_EXISTS;
    case Ye.PERMISSION_DENIED:
      return D2.PERMISSION_DENIED;
    case Ye.FAILED_PRECONDITION:
      return D2.FAILED_PRECONDITION;
    case Ye.ABORTED:
      return D2.ABORTED;
    case Ye.OUT_OF_RANGE:
      return D2.OUT_OF_RANGE;
    case Ye.UNIMPLEMENTED:
      return D2.UNIMPLEMENTED;
    case Ye.DATA_LOSS:
      return D2.DATA_LOSS;
    default:
      return L2();
  }
}
(Xe = Ye || (Ye = {}))[Xe.OK = 0] = "OK", Xe[Xe.CANCELLED = 1] = "CANCELLED", Xe[Xe.UNKNOWN = 2] = "UNKNOWN", Xe[Xe.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Xe[Xe.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Xe[Xe.NOT_FOUND = 5] = "NOT_FOUND", Xe[Xe.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Xe[Xe.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Xe[Xe.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Xe[Xe.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Xe[Xe.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Xe[Xe.ABORTED = 10] = "ABORTED", Xe[Xe.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Xe[Xe.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Xe[Xe.INTERNAL = 13] = "INTERNAL", Xe[Xe.UNAVAILABLE = 14] = "UNAVAILABLE", Xe[Xe.DATA_LOSS = 15] = "DATA_LOSS";
var en = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || sn.EMPTY;
  }
  insert(t2, e) {
    return new en(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, sn.BLACK, null, null));
  }
  remove(t2) {
    return new en(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, sn.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new nn(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new nn(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new nn(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new nn(this.root, t2, this.comparator, true);
  }
};
var nn = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var sn = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : sn.RED, this.left = s != null ? s : sn.EMPTY, this.right = i != null ? i : sn.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new sn(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return sn.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return sn.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, sn.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, sn.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw L2();
    if (this.right.isRed())
      throw L2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw L2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
sn.EMPTY = null, sn.RED = true, sn.BLACK = false;
sn.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw L2();
  }
  get value() {
    throw L2();
  }
  get color() {
    throw L2();
  }
  get left() {
    throw L2();
  }
  get right() {
    throw L2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new sn(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var rn = class {
  constructor(t2) {
    this.comparator = t2, this.data = new en(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new on(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new on(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof rn))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new rn(this.comparator);
    return e.data = t2, e;
  }
};
var on = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
var cn = new en(wt.comparator);
function un() {
  return cn;
}
var an = new en(wt.comparator);
function hn() {
  return an;
}
var ln = new en(wt.comparator);
function fn() {
  return ln;
}
var dn = new rn(wt.comparator);
function wn(...t2) {
  let e = dn;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var _n = new rn(j);
function mn() {
  return _n;
}
var gn = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = new Map();
    return n.set(t2, yn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new gn(z2.min(), n, mn(), un(), wn());
  }
};
var yn = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new yn(st.EMPTY_BYTE_STRING, e, wn(), wn(), wn());
  }
};
var pn = class {
  constructor(t2, e, n, s) {
    this.P = t2, this.removedTargetIds = e, this.key = n, this.v = s;
  }
};
var En = class {
  constructor(t2, e) {
    this.targetId = t2, this.V = e;
  }
};
var Tn = class {
  constructor(t2, e, n = st.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var In = class {
  constructor() {
    this.S = 0, this.D = Pn(), this.C = st.EMPTY_BYTE_STRING, this.N = false, this.k = true;
  }
  get current() {
    return this.N;
  }
  get resumeToken() {
    return this.C;
  }
  get $() {
    return this.S !== 0;
  }
  get O() {
    return this.k;
  }
  F(t2) {
    t2.approximateByteSize() > 0 && (this.k = true, this.C = t2);
  }
  M() {
    let t2 = wn(), e = wn(), n = wn();
    return this.D.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          L2();
      }
    }), new yn(this.C, this.N, t2, e, n);
  }
  L() {
    this.k = false, this.D = Pn();
  }
  B(t2, e) {
    this.k = true, this.D = this.D.insert(t2, e);
  }
  U(t2) {
    this.k = true, this.D = this.D.remove(t2);
  }
  q() {
    this.S += 1;
  }
  K() {
    this.S -= 1;
  }
  j() {
    this.k = true, this.N = true;
  }
};
var An = class {
  constructor(t2) {
    this.W = t2, this.G = new Map(), this.H = un(), this.J = Rn(), this.Y = new rn(j);
  }
  X(t2) {
    for (const e of t2.P)
      t2.v && t2.v.isFoundDocument() ? this.Z(e, t2.v) : this.tt(e, t2.key, t2.v);
    for (const e of t2.removedTargetIds)
      this.tt(e, t2.key, t2.v);
  }
  et(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.nt(e);
      switch (t2.state) {
        case 0:
          this.st(e) && n.F(t2.resumeToken);
          break;
        case 1:
          n.K(), n.$ || n.L(), n.F(t2.resumeToken);
          break;
        case 2:
          n.K(), n.$ || this.removeTarget(e);
          break;
        case 3:
          this.st(e) && (n.j(), n.F(t2.resumeToken));
          break;
        case 4:
          this.st(e) && (this.it(e), n.F(t2.resumeToken));
          break;
        default:
          L2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.G.forEach((t3, n) => {
      this.st(n) && e(n);
    });
  }
  rt(t2) {
    const e = t2.targetId, n = t2.V.count, s = this.ot(e);
    if (s) {
      const t3 = s.target;
      if (Ft(t3))
        if (n === 0) {
          const n2 = new wt(t3.path);
          this.tt(e, n2, Ct.newNoDocument(n2, z2.min()));
        } else
          B2(n === 1);
      else {
        this.ct(e) !== n && (this.it(e), this.Y = this.Y.add(e));
      }
    }
  }
  ut(t2) {
    const e = new Map();
    this.G.forEach((n2, s2) => {
      const i = this.ot(s2);
      if (i) {
        if (n2.current && Ft(i.target)) {
          const e2 = new wt(i.target.path);
          this.H.get(e2) !== null || this.at(s2, e2) || this.tt(s2, e2, Ct.newNoDocument(e2, t2));
        }
        n2.O && (e.set(s2, n2.M()), n2.L());
      }
    });
    let n = wn();
    this.J.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.ot(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    });
    const s = new gn(t2, e, this.Y, this.H, n);
    return this.H = un(), this.J = Rn(), this.Y = new rn(j), s;
  }
  Z(t2, e) {
    if (!this.st(t2))
      return;
    const n = this.at(t2, e.key) ? 2 : 0;
    this.nt(t2).B(e.key, n), this.H = this.H.insert(e.key, e), this.J = this.J.insert(e.key, this.ht(e.key).add(t2));
  }
  tt(t2, e, n) {
    if (!this.st(t2))
      return;
    const s = this.nt(t2);
    this.at(t2, e) ? s.B(e, 1) : s.U(e), this.J = this.J.insert(e, this.ht(e).delete(t2)), n && (this.H = this.H.insert(e, n));
  }
  removeTarget(t2) {
    this.G.delete(t2);
  }
  ct(t2) {
    const e = this.nt(t2).M();
    return this.W.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  q(t2) {
    this.nt(t2).q();
  }
  nt(t2) {
    let e = this.G.get(t2);
    return e || (e = new In(), this.G.set(t2, e)), e;
  }
  ht(t2) {
    let e = this.J.get(t2);
    return e || (e = new rn(j), this.J = this.J.insert(t2, e)), e;
  }
  st(t2) {
    const e = this.ot(t2) !== null;
    return e || $("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  ot(t2) {
    const e = this.G.get(t2);
    return e && e.$ ? null : this.W.lt(t2);
  }
  it(t2) {
    this.G.set(t2, new In());
    this.W.getRemoteKeysForTarget(t2).forEach((e) => {
      this.tt(t2, e, null);
    });
  }
  at(t2, e) {
    return this.W.getRemoteKeysForTarget(t2).has(e);
  }
};
function Rn() {
  return new en(wt.comparator);
}
function Pn() {
  return new en(wt.comparator);
}
var bn = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var vn = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var Vn = class {
  constructor(t2, e) {
    this.databaseId = t2, this.I = e;
  }
};
function Sn(t2, e) {
  if (t2.I) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Dn(t2, e) {
  return t2.I ? e.toBase64() : e.toUint8Array();
}
function Cn(t2, e) {
  return Sn(t2, e.toTimestamp());
}
function Nn(t2) {
  return B2(!!t2), z2.fromTimestamp(function(t3) {
    const e = rt(t3);
    return new G(e.seconds, e.nanos);
  }(t2));
}
function xn(t2, e) {
  return function(t3) {
    return new Z2(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function kn(t2) {
  const e = Z2.fromString(t2);
  return B2(us(e)), e;
}
function $n(t2, e) {
  return xn(t2.databaseId, e.path);
}
function On(t2, e) {
  const n = kn(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new C2(D2.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new C2(D2.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new wt(Bn(n));
}
function Fn(t2, e) {
  return xn(t2.databaseId, e);
}
function Mn(t2) {
  const e = kn(t2);
  return e.length === 4 ? Z2.emptyPath() : Bn(e);
}
function Ln(t2) {
  return new Z2(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Bn(t2) {
  return B2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function Un(t2, e, n) {
  return {
    name: $n(t2, e),
    fields: n.value.mapValue.fields
  };
}
function qn(t2, e, n) {
  const s = On(t2, e.name), i = Nn(e.updateTime), r = new St({
    mapValue: {
      fields: e.fields
    }
  }), o = Ct.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function Kn(t2, e) {
  return "found" in e ? function(t3, e2) {
    B2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = On(t3, e2.found.name), s = Nn(e2.found.updateTime), i = new St({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return Ct.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    B2(!!e2.missing), B2(!!e2.readTime);
    const n = On(t3, e2.missing), s = Nn(e2.readTime);
    return Ct.newNoDocument(n, s);
  }(t2, e) : L2();
}
function jn(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : L2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.I ? (B2(e2 === void 0 || typeof e2 == "string"), st.fromBase64String(e2 || "")) : (B2(e2 === void 0 || e2 instanceof Uint8Array), st.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, c = o && function(t3) {
      const e2 = t3.code === void 0 ? D2.UNKNOWN : tn(t3.code);
      return new C2(e2, t3.message || "");
    }(o);
    n = new Tn(s, i, r, c || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = On(t2, s.document.name), r = Nn(s.document.updateTime), o = new St({
      mapValue: {
        fields: s.document.fields
      }
    }), c = Ct.newFoundDocument(i, r, o), u = s.targetIds || [], a = s.removedTargetIds || [];
    n = new pn(u, a, c.key, c);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = On(t2, s.document), r = s.readTime ? Nn(s.readTime) : z2.min(), o = Ct.newNoDocument(i, r), c = s.removedTargetIds || [];
    n = new pn([], c, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = On(t2, s.document), r = s.removedTargetIds || [];
    n = new pn([], r, i, null);
  } else {
    if (!("filter" in e))
      return L2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new Je(s), r = t3.targetId;
      n = new En(r, i);
    }
  }
  return n;
}
function Qn(t2, e) {
  let n;
  if (e instanceof Ke)
    n = {
      update: Un(t2, e.key, e.value)
    };
  else if (e instanceof ze)
    n = {
      delete: $n(t2, e.key)
    };
  else if (e instanceof je)
    n = {
      update: Un(t2, e.key, e.data),
      updateMask: cs(e.fieldMask)
    };
  else {
    if (!(e instanceof He))
      return L2();
    n = {
      verify: $n(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof Re)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Pe)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof ve)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof Se)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.A
      };
    throw L2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: Cn(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : L2();
  }(t2, e.precondition)), n;
}
function Wn(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? $e.updateTime(Nn(t3.updateTime)) : t3.exists !== void 0 ? $e.exists(t3.exists) : $e.none();
  }(e.currentDocument) : $e.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      B2(e3.setToServerValue === "REQUEST_TIME"), n2 = new Re();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new Pe(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new ve(t4);
    } else
      "increment" in e3 ? n2 = new Se(t3, e3.increment) : L2();
    const s2 = et.fromServerFormat(e3.fieldPath);
    return new Ne(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = On(t2, e.update.name), r = new St({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new nt(e2.map((t5) => et.fromServerFormat(t5)));
      }(e.updateMask);
      return new je(i, r, t3, n, s);
    }
    return new Ke(i, r, n, s);
  }
  if (e.delete) {
    const s2 = On(t2, e.delete);
    return new ze(s2, n);
  }
  if (e.verify) {
    const s2 = On(t2, e.verify);
    return new He(s2, n);
  }
  return L2();
}
function Gn(t2, e) {
  return t2 && t2.length > 0 ? (B2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? Nn(t4.updateTime) : Nn(e2);
    return n.isEqual(z2.min()) && (n = Nn(e2)), new ke(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function zn(t2, e) {
  return {
    documents: [Fn(t2, e.path)]
  };
}
function Hn(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = Fn(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = Fn(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (bt(t5.value))
          return {
            unaryFilter: {
              field: ss(t5.field),
              op: "IS_NAN"
            }
          };
        if (Pt(t5.value))
          return {
            unaryFilter: {
              field: ss(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (bt(t5.value))
          return {
            unaryFilter: {
              field: ss(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Pt(t5.value))
          return {
            unaryFilter: {
              field: ss(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: ss(t5.field),
          op: ns(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: ss(t5.field),
        direction: es(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.I || lt(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = Zn(e.startAt)), e.endAt && (n.structuredQuery.endAt = Zn(e.endAt)), n;
}
function Jn(t2) {
  let e = Mn(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    B2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = Xn(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new Jt(is(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let c = null;
  n.limit && (c = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, lt(e2) ? null : e2;
  }(n.limit));
  let u = null;
  n.startAt && (u = ts(n.startAt));
  let a = null;
  return n.endAt && (a = ts(n.endAt)), ee(e, i, o, r, c, "F", u, a);
}
function Yn(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function Xn(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [os(t2)] : t2.fieldFilter !== void 0 ? [rs(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => Xn(t3)).reduce((t3, e) => t3.concat(e)) : L2() : [];
}
function Zn(t2) {
  return {
    before: t2.before,
    values: t2.position
  };
}
function ts(t2) {
  const e = !!t2.before, n = t2.values || [];
  return new zt(n, e);
}
function es(t2) {
  return bn[t2];
}
function ns(t2) {
  return vn[t2];
}
function ss(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function is(t2) {
  return et.fromServerFormat(t2.fieldPath);
}
function rs(t2) {
  return Mt.create(is(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      case "OPERATOR_UNSPECIFIED":
      default:
        return L2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function os(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = is(t2.unaryFilter.field);
      return Mt.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = is(t2.unaryFilter.field);
      return Mt.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = is(t2.unaryFilter.field);
      return Mt.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = is(t2.unaryFilter.field);
      return Mt.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    case "OPERATOR_UNSPECIFIED":
    default:
      return L2();
  }
}
function cs(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function us(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function as(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = ls(e)), e = hs(t2.get(n), e);
  return ls(e);
}
function hs(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function ls(t2) {
  return t2 + "";
}
function fs(t2) {
  const e = t2.length;
  if (B2(e >= 2), e === 2)
    return B2(t2.charAt(0) === "" && t2.charAt(1) === ""), Z2.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && L2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        L2();
    }
    r = e2 + 2;
  }
  return new Z2(s);
}
var ds = class {
  constructor(t2, e) {
    this.seconds = t2, this.nanoseconds = e;
  }
};
var ws = class {
  constructor(t2, e, n) {
    this.ownerId = t2, this.allowTabSynchronization = e, this.leaseTimestampMs = n;
  }
};
ws.store = "owner", ws.key = "owner";
var _s = class {
  constructor(t2, e, n) {
    this.userId = t2, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;
  }
};
_s.store = "mutationQueues", _s.keyPath = "userId";
var ms = class {
  constructor(t2, e, n, s, i) {
    this.userId = t2, this.batchId = e, this.localWriteTimeMs = n, this.baseMutations = s, this.mutations = i;
  }
};
ms.store = "mutations", ms.keyPath = "batchId", ms.userMutationsIndex = "userMutationsIndex", ms.userMutationsKeyPath = ["userId", "batchId"];
var gs = class {
  constructor() {
  }
  static prefixForUser(t2) {
    return [t2];
  }
  static prefixForPath(t2, e) {
    return [t2, as(e)];
  }
  static key(t2, e, n) {
    return [t2, as(e), n];
  }
};
gs.store = "documentMutations", gs.PLACEHOLDER = new gs();
var ys = class {
  constructor(t2, e) {
    this.path = t2, this.readTime = e;
  }
};
var ps = class {
  constructor(t2, e) {
    this.path = t2, this.version = e;
  }
};
var Es = class {
  constructor(t2, e, n, s, i, r) {
    this.unknownDocument = t2, this.noDocument = e, this.document = n, this.hasCommittedMutations = s, this.readTime = i, this.parentPath = r;
  }
};
Es.store = "remoteDocuments", Es.readTimeIndex = "readTimeIndex", Es.readTimeIndexPath = "readTime", Es.collectionReadTimeIndex = "collectionReadTimeIndex", Es.collectionReadTimeIndexPath = ["parentPath", "readTime"];
var Ts = class {
  constructor(t2) {
    this.byteSize = t2;
  }
};
Ts.store = "remoteDocumentGlobal", Ts.key = "remoteDocumentGlobalKey";
var Is = class {
  constructor(t2, e, n, s, i, r, o) {
    this.targetId = t2, this.canonicalId = e, this.readTime = n, this.resumeToken = s, this.lastListenSequenceNumber = i, this.lastLimboFreeSnapshotVersion = r, this.query = o;
  }
};
Is.store = "targets", Is.keyPath = "targetId", Is.queryTargetsIndexName = "queryTargetsIndex", Is.queryTargetsKeyPath = ["canonicalId", "targetId"];
var As = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.path = e, this.sequenceNumber = n;
  }
};
As.store = "targetDocuments", As.keyPath = ["targetId", "path"], As.documentTargetsIndex = "documentTargetsIndex", As.documentTargetsKeyPath = ["path", "targetId"];
var Rs = class {
  constructor(t2, e, n, s) {
    this.highestTargetId = t2, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = s;
  }
};
Rs.key = "targetGlobalKey", Rs.store = "targetGlobal";
var Ps = class {
  constructor(t2, e) {
    this.collectionId = t2, this.parent = e;
  }
};
Ps.store = "collectionParents", Ps.keyPath = ["collectionId", "parent"];
var bs = class {
  constructor(t2, e, n, s) {
    this.clientId = t2, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = s;
  }
};
bs.store = "clientMetadata", bs.keyPath = "clientId";
var vs = class {
  constructor(t2, e, n) {
    this.bundleId = t2, this.createTime = e, this.version = n;
  }
};
vs.store = "bundles", vs.keyPath = "bundleId";
var Vs = class {
  constructor(t2, e, n) {
    this.name = t2, this.readTime = e, this.bundledQuery = n;
  }
};
Vs.store = "namedQueries", Vs.keyPath = "name";
var Ss = [...[...[...[...[_s.store, ms.store, gs.store, Es.store, Is.store, ws.store, Rs.store, As.store], bs.store], Ts.store], Ps.store], vs.store, Vs.store];
var Ds = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var Cs = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
var Ns = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var xs = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && L2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new xs((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof xs ? e : xs.resolve(e);
    } catch (t3) {
      return xs.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : xs.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : xs.reject(e);
  }
  static resolve(t2) {
    return new xs((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new xs((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new xs((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = xs.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? xs.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
};
var ks = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.ft = new Ns(), this.transaction.oncomplete = () => {
      this.ft.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.ft.reject(new Fs(t2, e.error)) : this.ft.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = qs(e2.target.error);
      this.ft.reject(new Fs(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new ks(e, t2.transaction(s, n));
    } catch (t3) {
      throw new Fs(e, t3);
    }
  }
  get dt() {
    return this.ft.promise;
  }
  abort(t2) {
    t2 && this.ft.reject(t2), this.aborted || ($("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new Ls(e);
  }
};
var $s = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.wt = n;
    $s._t(getUA()) === 12.2 && O2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return $("SimpleDb", "Removing database:", t2), Bs(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static gt() {
    if (typeof indexedDB == "undefined")
      return false;
    if ($s.yt())
      return true;
    const t2 = getUA(), e = $s._t(t2), n = 0 < e && e < 10, s = $s.Et(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static yt() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.Tt) === "YES";
  }
  static It(t2, e) {
    return t2.store(e);
  }
  static _t(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static Et(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async At(t2) {
    return this.db || ($("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new Fs(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new C2(D2.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : n(new Fs(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        $("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.wt.Rt(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          $("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.Pt && (this.db.onversionchange = (t3) => this.Pt(t3)), this.db;
  }
  bt(t2) {
    this.Pt = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.At(t2);
        const e2 = ks.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).catch((t3) => (e2.abort(t3), xs.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.dt, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if ($("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var Os = class {
  constructor(t2) {
    this.vt = t2, this.Vt = false, this.St = null;
  }
  get isDone() {
    return this.Vt;
  }
  get Dt() {
    return this.St;
  }
  set cursor(t2) {
    this.vt = t2;
  }
  done() {
    this.Vt = true;
  }
  Ct(t2) {
    this.St = t2;
  }
  delete() {
    return Bs(this.vt.delete());
  }
};
var Fs = class extends C2 {
  constructor(t2, e) {
    super(D2.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function Ms(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var Ls = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? ($("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : ($("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), Bs(n);
  }
  add(t2) {
    $("SimpleDb", "ADD", this.store.name, t2, t2);
    return Bs(this.store.add(t2));
  }
  get(t2) {
    return Bs(this.store.get(t2)).next((e) => (e === void 0 && (e = null), $("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    $("SimpleDb", "DELETE", this.store.name, t2);
    return Bs(this.store.delete(t2));
  }
  count() {
    $("SimpleDb", "COUNT", this.store.name);
    return Bs(this.store.count());
  }
  Nt(t2, e) {
    const n = this.cursor(this.options(t2, e)), s = [];
    return this.xt(n, (t3, e2) => {
      s.push(e2);
    }).next(() => s);
  }
  kt(t2, e) {
    $("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.$t = false;
    const s = this.cursor(n);
    return this.xt(s, (t3, e2, n2) => n2.delete());
  }
  Ot(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.xt(s, e);
  }
  Ft(t2) {
    const e = this.cursor({});
    return new xs((n, s) => {
      e.onerror = (t3) => {
        const e2 = qs(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  xt(t2, e) {
    const n = [];
    return new xs((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new Os(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof xs) {
          const t4 = o.catch((t5) => (r.done(), xs.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.Dt === null ? i2.continue() : i2.continue(r.Dt);
      };
    }).next(() => xs.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.$t ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function Bs(t2) {
  return new xs((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = qs(t3.target.error);
      n(e2);
    };
  });
}
var Us = false;
function qs(t2) {
  const e = $s._t(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new C2("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return Us || (Us = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var Ks = class extends Cs {
  constructor(t2, e) {
    super(), this.Mt = t2, this.currentSequenceNumber = e;
  }
};
function js(t2, e) {
  const n = U2(t2);
  return $s.It(n.Mt, e);
}
var Qs = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        Me(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && Le(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && Le(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n = t2.get(e.key), s = n;
      this.applyToLocalView(s), n.isValidDocument() || s.convertToNoDocument(z2.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), wn());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && Q2(this.mutations, t2.mutations, (t3, e) => Ue(t3, e)) && Q2(this.baseMutations, t2.baseMutations, (t3, e) => Ue(t3, e));
  }
};
var Ws = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    B2(t2.mutations.length === n.length);
    let s = fn();
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new Ws(t2, e, n, s);
  }
};
var Gs = class {
  constructor(t2, e, n, s, i = z2.min(), r = z2.min(), o = st.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new Gs(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new Gs(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new Gs(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var zs = class {
  constructor(t2) {
    this.Lt = t2;
  }
};
function Hs(t2, e) {
  if (e.document)
    return qn(t2.Lt, e.document, !!e.hasCommittedMutations);
  if (e.noDocument) {
    const t3 = wt.fromSegments(e.noDocument.path), n = ti(e.noDocument.readTime), s = Ct.newNoDocument(t3, n);
    return e.hasCommittedMutations ? s.setHasCommittedMutations() : s;
  }
  if (e.unknownDocument) {
    const t3 = wt.fromSegments(e.unknownDocument.path), n = ti(e.unknownDocument.version);
    return Ct.newUnknownDocument(t3, n);
  }
  return L2();
}
function Js(t2, e, n) {
  const s = Ys(n), i = e.key.path.popLast().toArray();
  if (e.isFoundDocument()) {
    const n2 = function(t3, e2) {
      return {
        name: $n(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: Sn(t3, e2.version.toTimestamp())
      };
    }(t2.Lt, e), r = e.hasCommittedMutations;
    return new Es(null, null, n2, r, s, i);
  }
  if (e.isNoDocument()) {
    const t3 = e.key.path.toArray(), n2 = Zs(e.version), r = e.hasCommittedMutations;
    return new Es(null, new ys(t3, n2), null, r, s, i);
  }
  if (e.isUnknownDocument()) {
    const t3 = e.key.path.toArray(), n2 = Zs(e.version);
    return new Es(new ps(t3, n2), null, null, true, s, i);
  }
  return L2();
}
function Ys(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function Xs(t2) {
  const e = new G(t2[0], t2[1]);
  return z2.fromTimestamp(e);
}
function Zs(t2) {
  const e = t2.toTimestamp();
  return new ds(e.seconds, e.nanoseconds);
}
function ti(t2) {
  const e = new G(t2.seconds, t2.nanoseconds);
  return z2.fromTimestamp(e);
}
function ei(t2, e) {
  const n = (e.baseMutations || []).map((e2) => Wn(t2.Lt, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => Wn(t2.Lt, e2)), i = G.fromMillis(e.localWriteTimeMs);
  return new Qs(e.batchId, i, n, s);
}
function ni(t2) {
  const e = ti(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? ti(t2.lastLimboFreeSnapshotVersion) : z2.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (B2((i = t2.query).documents.length === 1), s = ae(ne(Mn(i.documents[0])))) : s = function(t3) {
    return ae(Jn(t3));
  }(t2.query), new Gs(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, st.fromBase64String(t2.resumeToken));
}
function si(t2, e) {
  const n = Zs(e.snapshotVersion), s = Zs(e.lastLimboFreeSnapshotVersion);
  let i;
  i = Ft(e.target) ? zn(t2.Lt, e.target) : Hn(t2.Lt, e.target);
  const r = e.resumeToken.toBase64();
  return new Is(e.targetId, kt(e.target), n, r, e.sequenceNumber, s, i);
}
function ii(t2) {
  const e = Jn({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? he(e, e.limit, "L") : e;
}
var ri = class {
  getBundleMetadata(t2, e) {
    return oi(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: ti(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return oi(t2).put({
      bundleId: (n = e).id,
      createTime: Zs(Nn(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return ci(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: ii(e2.bundledQuery),
          readTime: ti(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return ci(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: Zs(Nn(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function oi(t2) {
  return js(t2, vs.store);
}
function ci(t2) {
  return js(t2, Vs.store);
}
var ui = class {
  constructor() {
    this.Bt = new ai();
  }
  addToCollectionParentIndex(t2, e) {
    return this.Bt.add(e), xs.resolve();
  }
  getCollectionParents(t2, e) {
    return xs.resolve(this.Bt.getEntries(e));
  }
};
var ai = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new rn(Z2.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new rn(Z2.comparator)).toArray();
  }
};
var hi = class {
  constructor() {
    this.Ut = new ai();
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.Ut.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.Ut.add(e);
      });
      const i = {
        collectionId: n,
        parent: as(s)
      };
      return li(t2).put(i);
    }
    return xs.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [W2(e), ""], false, true);
    return li(t2).Nt(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(fs(s2.parent));
      }
      return n;
    });
  }
};
function li(t2) {
  return js(t2, Ps.store);
}
var fi = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var di = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new di(t2, di.DEFAULT_COLLECTION_PERCENTILE, di.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function wi(t2, e, n) {
  const s = t2.store(ms.store), i = t2.store(gs.store), r = [], o = IDBKeyRange.only(n.batchId);
  let c = 0;
  const u = s.Ot({
    range: o
  }, (t3, e2, n2) => (c++, n2.delete()));
  r.push(u.next(() => {
    B2(c === 1);
  }));
  const a = [];
  for (const t3 of n.mutations) {
    const s2 = gs.key(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), a.push(t3.key);
  }
  return xs.waitFor(r).next(() => a);
}
function _i(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw L2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
di.DEFAULT_COLLECTION_PERCENTILE = 10, di.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, di.DEFAULT = new di(41943040, di.DEFAULT_COLLECTION_PERCENTILE, di.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), di.DISABLED = new di(-1, 0, 0);
var mi = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.R = e, this.qt = n, this.referenceDelegate = s, this.Kt = {};
  }
  static jt(t2, e, n, s) {
    B2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new mi(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return yi(t2).Ot({
      index: ms.userMutationsIndex,
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = pi(t2), r = yi(t2);
    return r.add({}).next((o) => {
      B2(typeof o == "number");
      const c = new Qs(o, e, n, s), u = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => Qn(t3.Lt, e3)), i2 = n2.mutations.map((e3) => Qn(t3.Lt, e3));
        return new ms(e2, n2.batchId, n2.localWriteTime.toMillis(), s2, i2);
      }(this.R, this.userId, c), a = [];
      let h = new rn((t3, e2) => j(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = gs.key(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), a.push(r.put(u)), a.push(i.put(e2, gs.PLACEHOLDER));
      }
      return h.forEach((e2) => {
        a.push(this.qt.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.Kt[o] = c.keys();
      }), xs.waitFor(a).next(() => c);
    });
  }
  lookupMutationBatch(t2, e) {
    return yi(t2).get(e).next((t3) => t3 ? (B2(t3.userId === this.userId), ei(this.R, t3)) : null);
  }
  Qt(t2, e) {
    return this.Kt[e] ? xs.resolve(this.Kt[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.Kt[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return yi(t2).Ot({
      index: ms.userMutationsIndex,
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (B2(e2.batchId >= n), i = ei(this.R, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return yi(t2).Ot({
      index: ms.userMutationsIndex,
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return yi(t2).Nt(ms.userMutationsIndex, e).next((t3) => t3.map((t4) => ei(this.R, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = gs.prefixForPath(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return pi(t2).Ot({
      range: s
    }, (n2, s2, r) => {
      const [o, c, u] = n2, a = fs(c);
      if (o === this.userId && e.path.isEqual(a))
        return yi(t2).get(u).next((t3) => {
          if (!t3)
            throw L2();
          B2(t3.userId === this.userId), i.push(ei(this.R, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new rn(j);
    const s = [];
    return e.forEach((e2) => {
      const i = gs.prefixForPath(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = pi(t2).Ot({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, c] = t3, u = fs(o2);
        r2 === this.userId && e2.path.isEqual(u) ? n = n.add(c) : i2.done();
      });
      s.push(o);
    }), xs.waitFor(s).next(() => this.Wt(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = gs.prefixForPath(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new rn(j);
    return pi(t2).Ot({
      range: r
    }, (t3, e2, i2) => {
      const [r2, c, u] = t3, a = fs(c);
      r2 === this.userId && n.isPrefixOf(a) ? a.length === s && (o = o.add(u)) : i2.done();
    }).next(() => this.Wt(t2, o));
  }
  Wt(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(yi(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw L2();
        B2(t3.userId === this.userId), n.push(ei(this.R, t3));
      }));
    }), xs.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return wi(t2.Mt, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.Gt(e.batchId);
    }), xs.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  Gt(t2) {
    delete this.Kt[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return xs.resolve();
      const n = IDBKeyRange.lowerBound(gs.prefixForUser(this.userId)), s = [];
      return pi(t2).Ot({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = fs(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        B2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return gi(t2, this.userId, e);
  }
  zt(t2) {
    return Ei(t2).get(this.userId).next((t3) => t3 || new _s(this.userId, -1, ""));
  }
};
function gi(t2, e, n) {
  const s = gs.prefixForPath(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return pi(t2).Ot({
    range: r,
    $t: true
  }, (t3, n2, s2) => {
    const [r2, c, u] = t3;
    r2 === e && c === i && (o = true), s2.done();
  }).next(() => o);
}
function yi(t2) {
  return js(t2, ms.store);
}
function pi(t2) {
  return js(t2, gs.store);
}
function Ei(t2) {
  return js(t2, _s.store);
}
var Ti = class {
  constructor(t2) {
    this.Ht = t2;
  }
  next() {
    return this.Ht += 2, this.Ht;
  }
  static Jt() {
    return new Ti(0);
  }
  static Yt() {
    return new Ti(-1);
  }
};
var Ii = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.R = e;
  }
  allocateTargetId(t2) {
    return this.Xt(t2).next((e) => {
      const n = new Ti(e.highestTargetId);
      return e.highestTargetId = n.next(), this.Zt(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.Xt(t2).next((t3) => z2.fromTimestamp(new G(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.Xt(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.Xt(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.Zt(t2, s)));
  }
  addTargetData(t2, e) {
    return this.te(t2, e).next(() => this.Xt(t2).next((n) => (n.targetCount += 1, this.ee(e, n), this.Zt(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.te(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => Ai(t2).delete(e.targetId)).next(() => this.Xt(t2)).next((e2) => (B2(e2.targetCount > 0), e2.targetCount -= 1, this.Zt(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return Ai(t2).Ot((r, o) => {
      const c = ni(o);
      c.sequenceNumber <= e && n.get(c.targetId) === null && (s++, i.push(this.removeTargetData(t2, c)));
    }).next(() => xs.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return Ai(t2).Ot((t3, n) => {
      const s = ni(n);
      e(s);
    });
  }
  Xt(t2) {
    return Ri(t2).get(Rs.key).next((t3) => (B2(t3 !== null), t3));
  }
  Zt(t2, e) {
    return Ri(t2).put(Rs.key, e);
  }
  te(t2, e) {
    return Ai(t2).put(si(this.R, e));
  }
  ee(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.Xt(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = kt(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return Ai(t2).Ot({
      range: s,
      index: Is.queryTargetsIndexName
    }, (t3, n2, s2) => {
      const r = ni(n2);
      Ot(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = Pi(t2);
    return e.forEach((e2) => {
      const r = as(e2.path);
      s.push(i.put(new As(n, r))), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), xs.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = Pi(t2);
    return xs.forEach(e, (e2) => {
      const i = as(e2.path);
      return xs.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = Pi(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = Pi(t2);
    let i = wn();
    return s.Ot({
      range: n,
      $t: true
    }, (t3, e2, n2) => {
      const s2 = fs(t3[1]), r = new wt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = as(e.path), s = IDBKeyRange.bound([n], [W2(n)], false, true);
    let i = 0;
    return Pi(t2).Ot({
      index: As.documentTargetsIndex,
      $t: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  lt(t2, e) {
    return Ai(t2).get(e).next((t3) => t3 ? ni(t3) : null);
  }
};
function Ai(t2) {
  return js(t2, Is.store);
}
function Ri(t2) {
  return js(t2, Rs.store);
}
function Pi(t2) {
  return js(t2, As.store);
}
async function bi(t2) {
  if (t2.code !== D2.FAILED_PRECONDITION || t2.message !== Ds)
    throw t2;
  $("LocalStore", "Unexpectedly lost primary lease");
}
function vi([t2, e], [n, s]) {
  const i = j(t2, n);
  return i === 0 ? j(e, s) : i;
}
var Vi = class {
  constructor(t2) {
    this.ne = t2, this.buffer = new rn(vi), this.se = 0;
  }
  ie() {
    return ++this.se;
  }
  re(t2) {
    const e = [t2, this.ie()];
    if (this.buffer.size < this.ne)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      vi(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var Si = class {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.oe = false, this.ce = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.ue(t2);
  }
  stop() {
    this.ce && (this.ce.cancel(), this.ce = null);
  }
  get started() {
    return this.ce !== null;
  }
  ue(t2) {
    const e = this.oe ? 3e5 : 6e4;
    $("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.ce = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this.ce = null, this.oe = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        Ms(t3) ? $("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await bi(t3);
      }
      await this.ue(t2);
    });
  }
};
var Di = class {
  constructor(t2, e) {
    this.ae = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.ae.he(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return xs.resolve(S2.o);
    const n = new Vi(e);
    return this.ae.forEachTarget(t2, (t3) => n.re(t3.sequenceNumber)).next(() => this.ae.le(t2, (t3) => n.re(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.ae.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.ae.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? ($("LruGarbageCollector", "Garbage collection skipped; disabled"), xs.resolve(fi)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? ($("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), fi) : this.fe(t2, e));
  }
  getCacheSize(t2) {
    return this.ae.getCacheSize(t2);
  }
  fe(t2, e) {
    let n, s, i, r, o, c, u;
    const a = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? ($("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, c = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (u = Date.now(), x2() <= LogLevel.DEBUG) {
        $("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - a}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (c - o) + `ms
	Removed ${t3} documents in ` + (u - c) + `ms
Total Duration: ${u - a}ms`);
      }
      return xs.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var Ci = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new Di(t3, e2);
    }(this, e);
  }
  he(t2) {
    const e = this.de(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  de(t2) {
    let e = 0;
    return this.le(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  le(t2, e) {
    return this.we(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Ni(t2, n);
  }
  removeReference(t2, e, n) {
    return Ni(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Ni(t2, e);
  }
  _e(t2, e) {
    return function(t3, e2) {
      let n = false;
      return Ei(t3).Ft((s) => gi(t3, s, e2).next((t4) => (t4 && (n = true), xs.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.we(t2, (r, o) => {
      if (o <= e) {
        const e2 = this._e(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r), Pi(t2).delete([0, as(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => xs.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Ni(t2, e);
  }
  we(t2, e) {
    const n = Pi(t2);
    let s, i = S2.o;
    return n.Ot({
      index: As.documentTargetsIndex
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== S2.o && e(new wt(fs(s)), i), i = o, s = r) : i = S2.o;
    }).next(() => {
      i !== S2.o && e(new wt(fs(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Ni(t2, e) {
  return Pi(t2).put(function(t3, e2) {
    return new As(0, as(t3.path), e2);
  }(e, t2.currentSequenceNumber));
}
var xi = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {};
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s !== void 0) {
      for (let n2 = 0; n2 < s.length; n2++)
        if (this.equalsFn(s[n2][0], t2))
          return void (s[n2] = [t2, e]);
      s.push([t2, e]);
    } else
      this.inner[n] = [[t2, e]];
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), true;
    return false;
  }
  forEach(t2) {
    J2(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return Y2(this.inner);
  }
};
var ki = class {
  constructor() {
    this.changes = new xi((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  getReadTime(t2) {
    const e = this.changes.get(t2);
    return e ? e.readTime : z2.min();
  }
  addEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2.key, {
      document: t2,
      readTime: e
    });
  }
  removeEntry(t2, e = null) {
    this.assertNotApplied(), this.changes.set(t2, {
      document: Ct.newInvalidDocument(t2),
      readTime: e
    });
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? xs.resolve(n.document) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var $i = class {
  constructor(t2, e) {
    this.R = t2, this.qt = e;
  }
  addEntry(t2, e, n) {
    return Mi(t2).put(Li(e), n);
  }
  removeEntry(t2, e) {
    const n = Mi(t2), s = Li(e);
    return n.delete(s);
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.me(t2, n)));
  }
  getEntry(t2, e) {
    return Mi(t2).get(Li(e)).next((t3) => this.ge(e, t3));
  }
  ye(t2, e) {
    return Mi(t2).get(Li(e)).next((t3) => ({
      document: this.ge(e, t3),
      size: _i(t3)
    }));
  }
  getEntries(t2, e) {
    let n = un();
    return this.pe(t2, e, (t3, e2) => {
      const s = this.ge(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  Ee(t2, e) {
    let n = un(), s = new en(wt.comparator);
    return this.pe(t2, e, (t3, e2) => {
      const i = this.ge(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, _i(e2));
    }).next(() => ({
      documents: n,
      Te: s
    }));
  }
  pe(t2, e, n) {
    if (e.isEmpty())
      return xs.resolve();
    const s = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()), i = e.getIterator();
    let r = i.getNext();
    return Mi(t2).Ot({
      range: s
    }, (t3, e2, s2) => {
      const o = wt.fromSegments(t3);
      for (; r && wt.comparator(r, o) < 0; )
        n(r, null), r = i.getNext();
      r && r.isEqual(o) && (n(r, e2), r = i.hasNext() ? i.getNext() : null), r ? s2.Ct(r.path.toArray()) : s2.done();
    }).next(() => {
      for (; r; )
        n(r, null), r = i.hasNext() ? i.getNext() : null;
    });
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = un();
    const i = e.path.length + 1, r = {};
    if (n.isEqual(z2.min())) {
      const t3 = e.path.toArray();
      r.range = IDBKeyRange.lowerBound(t3);
    } else {
      const t3 = e.path.toArray(), s2 = Ys(n);
      r.range = IDBKeyRange.lowerBound([t3, s2], true), r.index = Es.collectionReadTimeIndex;
    }
    return Mi(t2).Ot(r, (t3, n2, r2) => {
      if (t3.length !== i)
        return;
      const o = Hs(this.R, n2);
      e.path.isPrefixOf(o.key.path) ? we(e, o) && (s = s.insert(o.key, o)) : r2.done();
    }).next(() => s);
  }
  newChangeBuffer(t2) {
    return new Oi(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Fi(t2).get(Ts.key).next((t3) => (B2(!!t3), t3));
  }
  me(t2, e) {
    return Fi(t2).put(Ts.key, e);
  }
  ge(t2, e) {
    if (e) {
      const t3 = Hs(this.R, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(z2.min())))
        return t3;
    }
    return Ct.newInvalidDocument(t2);
  }
};
var Oi = class extends ki {
  constructor(t2, e) {
    super(), this.Ie = t2, this.trackRemovals = e, this.Ae = new xi((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new rn((t3, e2) => j(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.Ae.get(i);
      if (r.document.isValidDocument()) {
        const c = Js(this.Ie.R, r.document, this.getReadTime(i));
        s = s.add(i.path.popLast());
        const u = _i(c);
        n += u - o, e.push(this.Ie.addEntry(t2, i, c));
      } else if (n -= o, this.trackRemovals) {
        const n2 = Js(this.Ie.R, Ct.newNoDocument(i, z2.min()), this.getReadTime(i));
        e.push(this.Ie.addEntry(t2, i, n2));
      } else
        e.push(this.Ie.removeEntry(t2, i));
    }), s.forEach((n2) => {
      e.push(this.Ie.qt.addToCollectionParentIndex(t2, n2));
    }), e.push(this.Ie.updateMetadata(t2, n)), xs.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Ie.ye(t2, e).next((t3) => (this.Ae.set(e, t3.size), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.Ie.Ee(t2, e).next(({ documents: t3, Te: e2 }) => (e2.forEach((t4, e3) => {
      this.Ae.set(t4, e3);
    }), t3));
  }
};
function Fi(t2) {
  return js(t2, Ts.store);
}
function Mi(t2) {
  return js(t2, Es.store);
}
function Li(t2) {
  return t2.path.toArray();
}
var Bi = class {
  constructor(t2) {
    this.R = t2;
  }
  Rt(t2, e, n, s) {
    B2(n < s && n >= 0 && s <= 11);
    const i = new ks("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore(ws.store);
    }(t2), function(t3) {
      t3.createObjectStore(_s.store, {
        keyPath: _s.keyPath
      });
      t3.createObjectStore(ms.store, {
        keyPath: ms.keyPath,
        autoIncrement: true
      }).createIndex(ms.userMutationsIndex, ms.userMutationsKeyPath, {
        unique: true
      }), t3.createObjectStore(gs.store);
    }(t2), Ui(t2), function(t3) {
      t3.createObjectStore(Es.store);
    }(t2));
    let r = xs.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore(As.store), t3.deleteObjectStore(Is.store), t3.deleteObjectStore(Rs.store);
    }(t2), Ui(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store(Rs.store), n2 = new Rs(0, 0, z2.min().toTimestamp(), 0);
      return e2.put(Rs.key, n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store(ms.store).Nt().next((n2) => {
        t3.deleteObjectStore(ms.store);
        t3.createObjectStore(ms.store, {
          keyPath: ms.keyPath,
          autoIncrement: true
        }).createIndex(ms.userMutationsIndex, ms.userMutationsKeyPath, {
          unique: true
        });
        const s2 = e2.store(ms.store), i2 = n2.map((t4) => s2.put(t4));
        return xs.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(bs.store, {
          keyPath: bs.keyPath
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Re(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore(Ts.store);
    }(t2), this.Pe(i)))), n < 7 && s >= 7 && (r = r.next(() => this.be(i))), n < 8 && s >= 8 && (r = r.next(() => this.ve(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2), function(t3) {
        const e2 = t3.objectStore(Es.store);
        e2.createIndex(Es.readTimeIndex, Es.readTimeIndexPath, {
          unique: false
        }), e2.createIndex(Es.collectionReadTimeIndex, Es.collectionReadTimeIndexPath, {
          unique: false
        });
      }(e);
    })), n < 10 && s >= 10 && (r = r.next(() => this.Ve(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(vs.store, {
          keyPath: vs.keyPath
        });
      }(t2), function(t3) {
        t3.createObjectStore(Vs.store, {
          keyPath: Vs.keyPath
        });
      }(t2);
    })), r;
  }
  Pe(t2) {
    let e = 0;
    return t2.store(Es.store).Ot((t3, n) => {
      e += _i(n);
    }).next(() => {
      const n = new Ts(e);
      return t2.store(Ts.store).put(Ts.key, n);
    });
  }
  Re(t2) {
    const e = t2.store(_s.store), n = t2.store(ms.store);
    return e.Nt().next((e2) => xs.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.Nt(ms.userMutationsIndex, s).next((n2) => xs.forEach(n2, (n3) => {
        B2(n3.userId === e3.userId);
        const s2 = ei(this.R, n3);
        return wi(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  be(t2) {
    const e = t2.store(As.store), n = t2.store(Es.store);
    return t2.store(Rs.store).get(Rs.key).next((t3) => {
      const s = [];
      return n.Ot((n2, i) => {
        const r = new Z2(n2), o = function(t4) {
          return [0, as(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? xs.resolve() : ((n4) => e.put(new As(0, as(n4), t3.highestListenSequenceNumber)))(r)));
      }).next(() => xs.waitFor(s));
    });
  }
  ve(t2, e) {
    t2.createObjectStore(Ps.store, {
      keyPath: Ps.keyPath
    });
    const n = e.store(Ps.store), s = new ai(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: as(s2)
        });
      }
    };
    return e.store(Es.store).Ot({
      $t: true
    }, (t3, e2) => {
      const n2 = new Z2(t3);
      return i(n2.popLast());
    }).next(() => e.store(gs.store).Ot({
      $t: true
    }, ([t3, e2, n2], s2) => {
      const r = fs(e2);
      return i(r.popLast());
    }));
  }
  Ve(t2) {
    const e = t2.store(Is.store);
    return e.Ot((t3, n) => {
      const s = ni(n), i = si(this.R, s);
      return e.put(i);
    });
  }
};
function Ui(t2) {
  t2.createObjectStore(As.store, {
    keyPath: As.keyPath
  }).createIndex(As.documentTargetsIndex, As.documentTargetsKeyPath, {
    unique: true
  });
  t2.createObjectStore(Is.store, {
    keyPath: Is.keyPath
  }).createIndex(Is.queryTargetsIndexName, Is.queryTargetsKeyPath, {
    unique: true
  }), t2.createObjectStore(Rs.store);
}
var qi = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var Ki = class {
  constructor(t2, e, n, s, i, r, o, c, u, a) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Se = i, this.window = r, this.document = o, this.De = u, this.Ce = a, this.Ne = null, this.xe = false, this.isPrimary = false, this.networkEnabled = true, this.ke = null, this.inForeground = false, this.$e = null, this.Oe = null, this.Fe = Number.NEGATIVE_INFINITY, this.Me = (t3) => Promise.resolve(), !Ki.gt())
      throw new C2(D2.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Ci(this, s), this.Le = e + "main", this.R = new zs(c), this.Be = new $s(this.Le, 11, new Bi(this.R)), this.Ue = new Ii(this.referenceDelegate, this.R), this.qt = new hi(), this.qe = function(t3, e2) {
      return new $i(t3, e2);
    }(this.R, this.qt), this.Ke = new ri(), this.window && this.window.localStorage ? this.je = this.window.localStorage : (this.je = null, a === false && O2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.Qe().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new C2(D2.FAILED_PRECONDITION, qi);
      return this.We(), this.Ge(), this.ze(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.Ue.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Ne = new S2(t2, this.De);
    }).then(() => {
      this.xe = true;
    }).catch((t2) => (this.Be && this.Be.close(), Promise.reject(t2)));
  }
  He(t2) {
    return this.Me = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.Be.bt(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Se.enqueueAndForget(async () => {
      this.started && await this.Qe();
    }));
  }
  Qe() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => Qi(t2).put(new bs(this.clientId, Date.now(), this.networkEnabled, this.inForeground)).next(() => {
      if (this.isPrimary)
        return this.Je(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Se.enqueueRetryable(() => this.Me(false)));
        });
    }).next(() => this.Ye(t2)).next((e) => this.isPrimary && !e ? this.Xe(t2).next(() => false) : !!e && this.Ze(t2).next(() => true))).catch((t2) => {
      if (Ms(t2))
        return $("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return $("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Se.enqueueRetryable(() => this.Me(t2)), this.isPrimary = t2;
    });
  }
  Je(t2) {
    return ji(t2).get(ws.key).next((t3) => xs.resolve(this.tn(t3)));
  }
  en(t2) {
    return Qi(t2).delete(this.clientId);
  }
  async nn() {
    if (this.isPrimary && !this.sn(this.Fe, 18e5)) {
      this.Fe = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = js(t3, bs.store);
        return e.Nt().next((t4) => {
          const n = this.rn(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return xs.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.je)
        for (const e of t2)
          this.je.removeItem(this.on(e.clientId));
    }
  }
  ze() {
    this.Oe = this.Se.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.Qe().then(() => this.nn()).then(() => this.ze()));
  }
  tn(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  Ye(t2) {
    if (this.Ce)
      return xs.resolve(true);
    return ji(t2).get(ws.key).next((e) => {
      if (e !== null && this.sn(e.leaseTimestampMs, 5e3) && !this.cn(e.ownerId)) {
        if (this.tn(e) && this.networkEnabled)
          return true;
        if (!this.tn(e)) {
          if (!e.allowTabSynchronization)
            throw new C2(D2.FAILED_PRECONDITION, qi);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || Qi(t2).Nt().next((t3) => this.rn(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && $("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.xe = false, this.un(), this.Oe && (this.Oe.cancel(), this.Oe = null), this.an(), this.hn(), await this.Be.runTransaction("shutdown", "readwrite", [ws.store, bs.store], (t2) => {
      const e = new Ks(t2, S2.o);
      return this.Xe(e).next(() => this.en(e));
    }), this.Be.close(), this.ln();
  }
  rn(t2, e) {
    return t2.filter((t3) => this.sn(t3.updateTimeMs, e) && !this.cn(t3.clientId));
  }
  fn() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => Qi(t2).Nt().next((t3) => this.rn(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.xe;
  }
  getMutationQueue(t2) {
    return mi.jt(t2, this.R, this.qt, this.referenceDelegate);
  }
  getTargetCache() {
    return this.Ue;
  }
  getRemoteDocumentCache() {
    return this.qe;
  }
  getIndexManager() {
    return this.qt;
  }
  getBundleCache() {
    return this.Ke;
  }
  runTransaction(t2, e, n) {
    $("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite";
    let i;
    return this.Be.runTransaction(t2, s, Ss, (s2) => (i = new Ks(s2, this.Ne ? this.Ne.next() : S2.o), e === "readwrite-primary" ? this.Je(i).next((t3) => !!t3 || this.Ye(i)).next((e2) => {
      if (!e2)
        throw O2(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Se.enqueueRetryable(() => this.Me(false)), new C2(D2.FAILED_PRECONDITION, Ds);
      return n(i);
    }).next((t3) => this.Ze(i).next(() => t3)) : this.dn(i).next(() => n(i)))).then((t3) => (i.raiseOnCommittedEvent(), t3));
  }
  dn(t2) {
    return ji(t2).get(ws.key).next((t3) => {
      if (t3 !== null && this.sn(t3.leaseTimestampMs, 5e3) && !this.cn(t3.ownerId) && !this.tn(t3) && !(this.Ce || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new C2(D2.FAILED_PRECONDITION, qi);
    });
  }
  Ze(t2) {
    const e = new ws(this.clientId, this.allowTabSynchronization, Date.now());
    return ji(t2).put(ws.key, e);
  }
  static gt() {
    return $s.gt();
  }
  Xe(t2) {
    const e = ji(t2);
    return e.get(ws.key).next((t3) => this.tn(t3) ? ($("IndexedDbPersistence", "Releasing primary lease."), e.delete(ws.key)) : xs.resolve());
  }
  sn(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || (O2(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  We() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.$e = () => {
      this.Se.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.Qe()));
    }, this.document.addEventListener("visibilitychange", this.$e), this.inForeground = this.document.visibilityState === "visible");
  }
  an() {
    this.$e && (this.document.removeEventListener("visibilitychange", this.$e), this.$e = null);
  }
  Ge() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.ke = () => {
      this.un(), isSafari() && navigator.appVersion.match("Version/14") && this.Se.enterRestrictedMode(true), this.Se.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.ke));
  }
  hn() {
    this.ke && (this.window.removeEventListener("pagehide", this.ke), this.ke = null);
  }
  cn(t2) {
    var e;
    try {
      const n = ((e = this.je) === null || e === void 0 ? void 0 : e.getItem(this.on(t2))) !== null;
      return $("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return O2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  un() {
    if (this.je)
      try {
        this.je.setItem(this.on(this.clientId), String(Date.now()));
      } catch (t2) {
        O2("Failed to set zombie client id.", t2);
      }
  }
  ln() {
    if (this.je)
      try {
        this.je.removeItem(this.on(this.clientId));
      } catch (t2) {
      }
  }
  on(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function ji(t2) {
  return js(t2, ws.store);
}
function Qi(t2) {
  return js(t2, bs.store);
}
function Wi(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var Gi = class {
  constructor(t2, e) {
    this.progress = t2, this.wn = e;
  }
};
var zi = class {
  constructor(t2, e, n) {
    this.qe = t2, this._n = e, this.qt = n;
  }
  mn(t2, e) {
    return this._n.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.gn(t2, e, n));
  }
  gn(t2, e, n) {
    return this.qe.getEntry(t2, e).next((t3) => {
      for (const e2 of n)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  yn(t2, e) {
    t2.forEach((t3, n) => {
      for (const t4 of e)
        t4.applyToLocalView(n);
    });
  }
  pn(t2, e) {
    return this.qe.getEntries(t2, e).next((e2) => this.En(t2, e2).next(() => e2));
  }
  En(t2, e) {
    return this._n.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.yn(e, t3));
  }
  getDocumentsMatchingQuery(t2, e, n) {
    return function(t3) {
      return wt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.Tn(t2, e.path) : ce(e) ? this.In(t2, e, n) : this.An(t2, e, n);
  }
  Tn(t2, e) {
    return this.mn(t2, new wt(e)).next((t3) => {
      let e2 = hn();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  In(t2, e, n) {
    const s = e.collectionGroup;
    let i = hn();
    return this.qt.getCollectionParents(t2, s).next((r) => xs.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new te(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.An(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  An(t2, e, n) {
    let s, i;
    return this.qe.getDocumentsMatchingQuery(t2, e, n).next((n2) => (s = n2, this._n.getAllMutationBatchesAffectingQuery(t2, e))).next((e2) => (i = e2, this.Rn(t2, i, s).next((t3) => {
      s = t3;
      for (const t4 of i)
        for (const e3 of t4.mutations) {
          const n2 = e3.key;
          let i2 = s.get(n2);
          i2 == null && (i2 = Ct.newInvalidDocument(n2), s = s.insert(n2, i2)), Le(e3, i2, t4.localWriteTime), i2.isFoundDocument() || (s = s.remove(n2));
        }
    }))).next(() => (s.forEach((t3, n2) => {
      we(e, n2) || (s = s.remove(t3));
    }), s));
  }
  Rn(t2, e, n) {
    let s = wn();
    for (const t3 of e)
      for (const e2 of t3.mutations)
        e2 instanceof je && n.get(e2.key) === null && (s = s.add(e2.key));
    let i = n;
    return this.qe.getEntries(t2, s).next((t3) => (t3.forEach((t4, e2) => {
      e2.isFoundDocument() && (i = i.insert(t4, e2));
    }), i));
  }
};
var Hi = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.Pn = n, this.bn = s;
  }
  static vn(t2, e) {
    let n = wn(), s = wn();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new Hi(t2, e.fromCache, n, s);
  }
};
var Ji = class {
  Vn(t2) {
    this.Sn = t2;
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n.isEqual(z2.min()) ? this.Dn(t2, e) : this.Sn.pn(t2, s).next((i) => {
      const r = this.Cn(e, i);
      return (se(e) || ie(e)) && this.Nn(e.limitType, r, s, n) ? this.Dn(t2, e) : (x2() <= LogLevel.DEBUG && $("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), de(e)), this.Sn.getDocumentsMatchingQuery(t2, e, n).next((t3) => (r.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  Cn(t2, e) {
    let n = new rn(_e(t2));
    return e.forEach((e2, s) => {
      we(t2, s) && (n = n.add(s));
    }), n;
  }
  Nn(t2, e, n, s) {
    if (n.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Dn(t2, e) {
    return x2() <= LogLevel.DEBUG && $("QueryEngine", "Using full collection scan to execute query:", de(e)), this.Sn.getDocumentsMatchingQuery(t2, e, z2.min());
  }
};
var Yi = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.xn = e, this.R = s, this.kn = new en(j), this.$n = new xi((t3) => kt(t3), Ot), this.On = z2.min(), this._n = t2.getMutationQueue(n), this.Fn = t2.getRemoteDocumentCache(), this.Ue = t2.getTargetCache(), this.Mn = new zi(this.Fn, this._n, this.persistence.getIndexManager()), this.Ke = t2.getBundleCache(), this.xn.Vn(this.Mn);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.kn));
  }
};
function Xi(t2, e, n, s) {
  return new Yi(t2, e, n, s);
}
async function Zi(t2, e) {
  const n = U2(t2);
  let s = n._n, i = n.Mn;
  const r = await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let r2;
    return n._n.getAllMutationBatches(t3).next((o) => (r2 = o, s = n.persistence.getMutationQueue(e), i = new zi(n.Fn, s, n.persistence.getIndexManager()), s.getAllMutationBatches(t3))).next((e2) => {
      const n2 = [], s2 = [];
      let o = wn();
      for (const t4 of r2) {
        n2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        s2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return i.pn(t3, o).next((t4) => ({
        Ln: t4,
        removedBatchIds: n2,
        addedBatchIds: s2
      }));
    });
  });
  return n._n = s, n.Mn = i, n.xn.Vn(n.Mn), r;
}
function tr(t2, e) {
  const n = U2(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.Fn.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = xs.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          B2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && s2.addEntry(e3, n2.commitVersion));
        });
      }), o.next(() => t4._n.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n._n.performConsistencyCheck(t3)).next(() => n.Mn.pn(t3, s));
  });
}
function er(t2) {
  const e = U2(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.Ue.getLastRemoteSnapshotVersion(t3));
}
function nr(t2, e) {
  const n = U2(t2), s = e.snapshotVersion;
  let i = n.kn;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.Fn.newChangeBuffer({
      trackRemovals: true
    });
    i = n.kn;
    const o = [];
    e.targetChanges.forEach((e2, r2) => {
      const c2 = i.get(r2);
      if (!c2)
        return;
      o.push(n.Ue.removeMatchingKeys(t3, e2.removedDocuments, r2).next(() => n.Ue.addMatchingKeys(t3, e2.addedDocuments, r2)));
      const u = e2.resumeToken;
      if (u.approximateByteSize() > 0) {
        const a = c2.withResumeToken(u, s).withSequenceNumber(t3.currentSequenceNumber);
        i = i.insert(r2, a), function(t4, e3, n2) {
          if (B2(e3.resumeToken.approximateByteSize() > 0), t4.resumeToken.approximateByteSize() === 0)
            return true;
          if (e3.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
            return true;
          return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
        }(c2, a, e2) && o.push(n.Ue.updateTargetData(t3, a));
      }
    });
    let c = un();
    if (e.documentUpdates.forEach((s2, i2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(sr(t3, r, e.documentUpdates, s, void 0).next((t4) => {
      c = t4;
    })), !s.isEqual(z2.min())) {
      const e2 = n.Ue.getLastRemoteSnapshotVersion(t3).next((e3) => n.Ue.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return xs.waitFor(o).next(() => r.apply(t3)).next(() => n.Mn.En(t3, c)).next(() => c);
  }).then((t3) => (n.kn = i, t3));
}
function sr(t2, e, n, s, i) {
  let r = wn();
  return n.forEach((t3) => r = r.add(t3)), e.getEntries(t2, r).next((t3) => {
    let r2 = un();
    return n.forEach((n2, o) => {
      const c = t3.get(n2), u = (i == null ? void 0 : i.get(n2)) || s;
      o.isNoDocument() && o.version.isEqual(z2.min()) ? (e.removeEntry(n2, u), r2 = r2.insert(n2, o)) : !c.isValidDocument() || o.version.compareTo(c.version) > 0 || o.version.compareTo(c.version) === 0 && c.hasPendingWrites ? (e.addEntry(o, u), r2 = r2.insert(n2, o)) : $("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", c.version, " Watch version:", o.version);
    }), r2;
  });
}
function ir(t2, e) {
  const n = U2(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n._n.getNextMutationBatchAfterBatchId(t3, e)));
}
function rr(t2, e) {
  const n = U2(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.Ue.getTargetData(t3, e).next((i) => i ? (s = i, xs.resolve(s)) : n.Ue.allocateTargetId(t3).next((i2) => (s = new Gs(e, i2, 0, t3.currentSequenceNumber), n.Ue.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.kn.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.kn = n.kn.insert(t3.targetId, t3), n.$n.set(e, t3.targetId)), t3;
  });
}
async function or(t2, e, n) {
  const s = U2(t2), i = s.kn.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Ms(t3))
      throw t3;
    $("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.kn = s.kn.remove(e), s.$n.delete(i.target);
}
function cr(t2, e, n) {
  const s = U2(t2);
  let i = z2.min(), r = wn();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = U2(t4), i2 = s2.$n.get(n2);
    return i2 !== void 0 ? xs.resolve(s2.kn.get(i2)) : s2.Ue.getTargetData(e2, n2);
  }(s, t3, ae(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.Ue.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.xn.getDocumentsMatchingQuery(t3, e, n ? i : z2.min(), n ? r : wn())).next((t4) => ({
    documents: t4,
    Bn: r
  })));
}
function ur(t2, e) {
  const n = U2(t2), s = U2(n.Ue), i = n.kn.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.lt(t3, e).next((t4) => t4 ? t4.target : null));
}
function ar(t2) {
  const e = U2(t2);
  return e.persistence.runTransaction("Get new document changes", "readonly", (t3) => function(t4, e2, n) {
    const s = U2(t4);
    let i = un(), r = Ys(n);
    const o = Mi(e2), c = IDBKeyRange.lowerBound(r, true);
    return o.Ot({
      index: Es.readTimeIndex,
      range: c
    }, (t5, e3) => {
      const n2 = Hs(s.R, e3);
      i = i.insert(n2.key, n2), r = e3.readTime;
    }).next(() => ({
      wn: i,
      readTime: Xs(r)
    }));
  }(e.Fn, t3, e.On)).then(({ wn: t3, readTime: n }) => (e.On = n, t3));
}
async function hr(t2) {
  const e = U2(t2);
  return e.persistence.runTransaction("Synchronize last document change read time", "readonly", (t3) => function(t4) {
    const e2 = Mi(t4);
    let n = z2.min();
    return e2.Ot({
      index: Es.readTimeIndex,
      reverse: true
    }, (t5, e3, s) => {
      e3.readTime && (n = Xs(e3.readTime)), s.done();
    }).next(() => n);
  }(t3)).then((t3) => {
    e.On = t3;
  });
}
async function lr(t2, e, n, s) {
  const i = U2(t2);
  let r = wn(), o = un(), c = fn();
  for (const t3 of n) {
    const n2 = e.Un(t3.metadata.name);
    t3.document && (r = r.add(n2)), o = o.insert(n2, e.qn(t3)), c = c.insert(n2, e.Kn(t3.metadata.readTime));
  }
  const u = i.Fn.newChangeBuffer({
    trackRemovals: true
  }), a = await rr(i, function(t3) {
    return ae(ne(Z2.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => sr(t3, u, o, z2.min(), c).next((e2) => (u.apply(t3), e2)).next((e2) => i.Ue.removeMatchingKeysForTargetId(t3, a.targetId).next(() => i.Ue.addMatchingKeys(t3, r, a.targetId)).next(() => i.Mn.En(t3, e2)).next(() => e2)));
}
async function fr(t2, e, n = wn()) {
  const s = await rr(t2, ae(ii(e.bundledQuery))), i = U2(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = Nn(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.Ke.saveNamedQuery(t3, e);
    const o = s.withResumeToken(st.EMPTY_BYTE_STRING, r);
    return i.kn = i.kn.insert(o.targetId, o), i.Ue.updateTargetData(t3, o).next(() => i.Ue.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.Ue.addMatchingKeys(t3, n, s.targetId)).next(() => i.Ke.saveNamedQuery(t3, e));
  });
}
var dr = class {
  constructor(t2) {
    this.R = t2, this.jn = new Map(), this.Qn = new Map();
  }
  getBundleMetadata(t2, e) {
    return xs.resolve(this.jn.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.jn.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: Nn(n.createTime)
    }), xs.resolve();
  }
  getNamedQuery(t2, e) {
    return xs.resolve(this.Qn.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.Qn.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: ii(t3.bundledQuery),
        readTime: Nn(t3.readTime)
      };
    }(e)), xs.resolve();
  }
};
var wr = class {
  constructor() {
    this.Wn = new rn(_r.Gn), this.zn = new rn(_r.Hn);
  }
  isEmpty() {
    return this.Wn.isEmpty();
  }
  addReference(t2, e) {
    const n = new _r(t2, e);
    this.Wn = this.Wn.add(n), this.zn = this.zn.add(n);
  }
  Jn(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.Yn(new _r(t2, e));
  }
  Xn(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  Zn(t2) {
    const e = new wt(new Z2([])), n = new _r(e, t2), s = new _r(e, t2 + 1), i = [];
    return this.zn.forEachInRange([n, s], (t3) => {
      this.Yn(t3), i.push(t3.key);
    }), i;
  }
  ts() {
    this.Wn.forEach((t2) => this.Yn(t2));
  }
  Yn(t2) {
    this.Wn = this.Wn.delete(t2), this.zn = this.zn.delete(t2);
  }
  es(t2) {
    const e = new wt(new Z2([])), n = new _r(e, t2), s = new _r(e, t2 + 1);
    let i = wn();
    return this.zn.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new _r(t2, 0), n = this.Wn.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var _r = class {
  constructor(t2, e) {
    this.key = t2, this.ns = e;
  }
  static Gn(t2, e) {
    return wt.comparator(t2.key, e.key) || j(t2.ns, e.ns);
  }
  static Hn(t2, e) {
    return j(t2.ns, e.ns) || wt.comparator(t2.key, e.key);
  }
};
var mr = class {
  constructor(t2, e) {
    this.qt = t2, this.referenceDelegate = e, this._n = [], this.ss = 1, this.rs = new rn(_r.Gn);
  }
  checkEmpty(t2) {
    return xs.resolve(this._n.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.ss;
    this.ss++, this._n.length > 0 && this._n[this._n.length - 1];
    const r = new Qs(i, e, n, s);
    this._n.push(r);
    for (const e2 of s)
      this.rs = this.rs.add(new _r(e2.key, i)), this.qt.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return xs.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return xs.resolve(this.os(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this.cs(n), i = s < 0 ? 0 : s;
    return xs.resolve(this._n.length > i ? this._n[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return xs.resolve(this._n.length === 0 ? -1 : this.ss - 1);
  }
  getAllMutationBatches(t2) {
    return xs.resolve(this._n.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new _r(e, 0), s = new _r(e, Number.POSITIVE_INFINITY), i = [];
    return this.rs.forEachInRange([n, s], (t3) => {
      const e2 = this.os(t3.ns);
      i.push(e2);
    }), xs.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new rn(j);
    return e.forEach((t3) => {
      const e2 = new _r(t3, 0), s = new _r(t3, Number.POSITIVE_INFINITY);
      this.rs.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.ns);
      });
    }), xs.resolve(this.us(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    wt.isDocumentKey(i) || (i = i.child(""));
    const r = new _r(new wt(i), 0);
    let o = new rn(j);
    return this.rs.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.ns)), true);
    }, r), xs.resolve(this.us(o));
  }
  us(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this.os(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    B2(this.hs(e.batchId, "removed") === 0), this._n.shift();
    let n = this.rs;
    return xs.forEach(e.mutations, (s) => {
      const i = new _r(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.rs = n;
    });
  }
  Gt(t2) {
  }
  containsKey(t2, e) {
    const n = new _r(e, 0), s = this.rs.firstAfterOrEqual(n);
    return xs.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this._n.length, xs.resolve();
  }
  hs(t2, e) {
    return this.cs(t2);
  }
  cs(t2) {
    if (this._n.length === 0)
      return 0;
    return t2 - this._n[0].batchId;
  }
  os(t2) {
    const e = this.cs(t2);
    if (e < 0 || e >= this._n.length)
      return null;
    return this._n[e];
  }
};
var gr = class {
  constructor(t2, e) {
    this.qt = t2, this.ls = e, this.docs = new en(wt.comparator), this.size = 0;
  }
  addEntry(t2, e, n) {
    const s = e.key, i = this.docs.get(s), r = i ? i.size : 0, o = this.ls(e);
    return this.docs = this.docs.insert(s, {
      document: e.clone(),
      size: o,
      readTime: n
    }), this.size += o - r, this.qt.addToCollectionParentIndex(t2, s.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return xs.resolve(n ? n.document.clone() : Ct.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = un();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.clone() : Ct.newInvalidDocument(t3));
    }), xs.resolve(n);
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = un();
    const i = new wt(e.path.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2, readTime: o } } = r.getNext();
      if (!e.path.isPrefixOf(t3.path))
        break;
      o.compareTo(n) <= 0 || we(e, i2) && (s = s.insert(i2.key, i2.clone()));
    }
    return xs.resolve(s);
  }
  fs(t2, e) {
    return xs.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new yr(this);
  }
  getSize(t2) {
    return xs.resolve(this.size);
  }
};
var yr = class extends ki {
  constructor(t2) {
    super(), this.Ie = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.document.isValidDocument() ? e.push(this.Ie.addEntry(t2, s.document, this.getReadTime(n))) : this.Ie.removeEntry(n);
    }), xs.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Ie.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.Ie.getEntries(t2, e);
  }
};
var pr = class {
  constructor(t2) {
    this.persistence = t2, this.ds = new xi((t3) => kt(t3), Ot), this.lastRemoteSnapshotVersion = z2.min(), this.highestTargetId = 0, this.ws = 0, this._s = new wr(), this.targetCount = 0, this.gs = Ti.Jt();
  }
  forEachTarget(t2, e) {
    return this.ds.forEach((t3, n) => e(n)), xs.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return xs.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return xs.resolve(this.ws);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.gs.next(), xs.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.ws && (this.ws = e), xs.resolve();
  }
  te(t2) {
    this.ds.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.gs = new Ti(e), this.highestTargetId = e), t2.sequenceNumber > this.ws && (this.ws = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.te(e), this.targetCount += 1, xs.resolve();
  }
  updateTargetData(t2, e) {
    return this.te(e), xs.resolve();
  }
  removeTargetData(t2, e) {
    return this.ds.delete(e.target), this._s.Zn(e.targetId), this.targetCount -= 1, xs.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.ds.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.ds.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), xs.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return xs.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.ds.get(e) || null;
    return xs.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this._s.Jn(e, n), xs.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this._s.Xn(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), xs.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this._s.Zn(e), xs.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this._s.es(e);
    return xs.resolve(n);
  }
  containsKey(t2, e) {
    return xs.resolve(this._s.containsKey(e));
  }
};
var Er = class {
  constructor(t2, e) {
    this.ys = {}, this.Ne = new S2(0), this.xe = false, this.xe = true, this.referenceDelegate = t2(this), this.Ue = new pr(this);
    this.qt = new ui(), this.qe = function(t3, e2) {
      return new gr(t3, e2);
    }(this.qt, (t3) => this.referenceDelegate.ps(t3)), this.R = new zs(e), this.Ke = new dr(this.R);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.xe = false, Promise.resolve();
  }
  get started() {
    return this.xe;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager() {
    return this.qt;
  }
  getMutationQueue(t2) {
    let e = this.ys[t2.toKey()];
    return e || (e = new mr(this.qt, this.referenceDelegate), this.ys[t2.toKey()] = e), e;
  }
  getTargetCache() {
    return this.Ue;
  }
  getRemoteDocumentCache() {
    return this.qe;
  }
  getBundleCache() {
    return this.Ke;
  }
  runTransaction(t2, e, n) {
    $("MemoryPersistence", "Starting transaction:", t2);
    const s = new Tr(this.Ne.next());
    return this.referenceDelegate.Es(), n(s).next((t3) => this.referenceDelegate.Ts(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Is(t2, e) {
    return xs.or(Object.values(this.ys).map((n) => () => n.containsKey(t2, e)));
  }
};
var Tr = class extends Cs {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var Ir = class {
  constructor(t2) {
    this.persistence = t2, this.As = new wr(), this.Rs = null;
  }
  static Ps(t2) {
    return new Ir(t2);
  }
  get bs() {
    if (this.Rs)
      return this.Rs;
    throw L2();
  }
  addReference(t2, e, n) {
    return this.As.addReference(n, e), this.bs.delete(n.toString()), xs.resolve();
  }
  removeReference(t2, e, n) {
    return this.As.removeReference(n, e), this.bs.add(n.toString()), xs.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.bs.add(e.toString()), xs.resolve();
  }
  removeTarget(t2, e) {
    this.As.Zn(e.targetId).forEach((t3) => this.bs.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.bs.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  Es() {
    this.Rs = new Set();
  }
  Ts(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return xs.forEach(this.bs, (n) => {
      const s = wt.fromPath(n);
      return this.vs(t2, s).next((t3) => {
        t3 || e.removeEntry(s);
      });
    }).next(() => (this.Rs = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.vs(t2, e).next((t3) => {
      t3 ? this.bs.delete(e.toString()) : this.bs.add(e.toString());
    });
  }
  ps(t2) {
    return 0;
  }
  vs(t2, e) {
    return xs.or([() => xs.resolve(this.As.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Is(t2, e)]);
  }
};
var Ar = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
Ar.UNAUTHENTICATED = new Ar(null), Ar.GOOGLE_CREDENTIALS = new Ar("google-credentials-uid"), Ar.FIRST_PARTY = new Ar("first-party-uid");
function Rr(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function Pr(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function br(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var vr = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static Vs(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new C2(s.error.code, s.error.message))), r ? new vr(t2, e, s.state, i) : (O2("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Ss() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Vr = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static Vs(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new C2(n.error.code, n.error.message))), i ? new Vr(t2, n.state, s) : (O2("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Ss() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Sr = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Vs(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = mn();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = dt(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new Sr(t2, i) : (O2("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var Dr = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Vs(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new Dr(e.clientId, e.onlineState) : (O2("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var Cr = class {
  constructor() {
    this.activeTargetIds = mn();
  }
  Ds(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Cs(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Ss() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var Nr = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Se = e, this.persistenceKey = n, this.Ns = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.xs = this.ks.bind(this), this.$s = new en(j), this.started = false, this.Os = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.Fs = Rr(this.persistenceKey, this.Ns), this.Ms = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.$s = this.$s.insert(this.Ns, new Cr()), this.Ls = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.Bs = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.Us = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.qs = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.Ks = function(t3) {
      return `firestore_bundle_loaded_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.xs);
  }
  static gt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.fn();
    for (const e2 of t2) {
      if (e2 === this.Ns)
        continue;
      const t3 = this.getItem(Rr(this.persistenceKey, e2));
      if (t3) {
        const n = Sr.Vs(e2, t3);
        n && (this.$s = this.$s.insert(n.clientId, n));
      }
    }
    this.js();
    const e = this.storage.getItem(this.qs);
    if (e) {
      const t3 = this.Qs(e);
      t3 && this.Ws(t3);
    }
    for (const t3 of this.Os)
      this.ks(t3);
    this.Os = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.Ms, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.Gs(this.$s);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.$s.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.zs(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.zs(t2, e, n), this.Hs(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(br(this.persistenceKey, t2));
      if (n) {
        const s = Vr.Vs(t2, n);
        s && (e = s.state);
      }
    }
    return this.Js.Ds(t2), this.js(), e;
  }
  removeLocalQueryTarget(t2) {
    this.Js.Cs(t2), this.js();
  }
  isLocalQueryTarget(t2) {
    return this.Js.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(br(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.Ys(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.Hs(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.Xs(t2);
  }
  notifyBundleLoaded() {
    this.Zs();
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.xs), this.removeItem(this.Fs), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return $("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    $("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    $("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  ks(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if ($("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.Fs)
        return void O2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Se.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.Ls.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.ti(e.key);
                return this.ei(t3, null);
              }
              {
                const t3 = this.ni(e.key, e.newValue);
                if (t3)
                  return this.ei(t3.clientId, t3);
              }
            } else if (this.Bs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.si(e.key, e.newValue);
                if (t3)
                  return this.ii(t3);
              }
            } else if (this.Us.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.ri(e.key, e.newValue);
                if (t3)
                  return this.oi(t3);
              }
            } else if (e.key === this.qs) {
              if (e.newValue !== null) {
                const t3 = this.Qs(e.newValue);
                if (t3)
                  return this.Ws(t3);
              }
            } else if (e.key === this.Ms) {
              const t3 = function(t4) {
                let e2 = S2.o;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    B2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    O2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== S2.o && this.sequenceNumberHandler(t3);
            } else if (e.key === this.Ks)
              return this.syncEngine.ci();
          }
        } else
          this.Os.push(e);
      });
    }
  }
  get Js() {
    return this.$s.get(this.Ns);
  }
  js() {
    this.setItem(this.Fs, this.Js.Ss());
  }
  zs(t2, e, n) {
    const s = new vr(this.currentUser, t2, e, n), i = Pr(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Ss());
  }
  Hs(t2) {
    const e = Pr(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  Xs(t2) {
    const e = {
      clientId: this.Ns,
      onlineState: t2
    };
    this.storage.setItem(this.qs, JSON.stringify(e));
  }
  Ys(t2, e, n) {
    const s = br(this.persistenceKey, t2), i = new Vr(t2, e, n);
    this.setItem(s, i.Ss());
  }
  Zs() {
    this.setItem(this.Ks, "value-not-used");
  }
  ti(t2) {
    const e = this.Ls.exec(t2);
    return e ? e[1] : null;
  }
  ni(t2, e) {
    const n = this.ti(t2);
    return Sr.Vs(n, e);
  }
  si(t2, e) {
    const n = this.Bs.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return vr.Vs(new Ar(i), s, e);
  }
  ri(t2, e) {
    const n = this.Us.exec(t2), s = Number(n[1]);
    return Vr.Vs(s, e);
  }
  Qs(t2) {
    return Dr.Vs(t2);
  }
  async ii(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.ui(t2.batchId, t2.state, t2.error);
    $("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  oi(t2) {
    return this.syncEngine.ai(t2.targetId, t2.state, t2.error);
  }
  ei(t2, e) {
    const n = e ? this.$s.insert(t2, e) : this.$s.remove(t2), s = this.Gs(this.$s), i = this.Gs(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.hi(r, o).then(() => {
      this.$s = n;
    });
  }
  Ws(t2) {
    this.$s.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  Gs(t2) {
    let e = mn();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var xr = class {
  constructor() {
    this.li = new Cr(), this.fi = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.li.Ds(t2), this.fi[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.fi[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.li.Cs(t2);
  }
  isLocalQueryTarget(t2) {
    return this.li.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.fi[t2];
  }
  getAllActiveQueryTargets() {
    return this.li.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.li.activeTargetIds.has(t2);
  }
  start() {
    return this.li = new Cr(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded() {
  }
};
var kr = class {
  di(t2) {
  }
  shutdown() {
  }
};
var $r = class {
  constructor() {
    this.wi = () => this._i(), this.mi = () => this.gi(), this.yi = [], this.pi();
  }
  di(t2) {
    this.yi.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.wi), window.removeEventListener("offline", this.mi);
  }
  pi() {
    window.addEventListener("online", this.wi), window.addEventListener("offline", this.mi);
  }
  _i() {
    $("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.yi)
      t2(0);
  }
  gi() {
    $("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.yi)
      t2(1);
  }
  static gt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var Or = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var Fr = class {
  constructor(t2) {
    this.Ei = t2.Ei, this.Ti = t2.Ti;
  }
  Ii(t2) {
    this.Ai = t2;
  }
  Ri(t2) {
    this.Pi = t2;
  }
  onMessage(t2) {
    this.bi = t2;
  }
  close() {
    this.Ti();
  }
  send(t2) {
    this.Ei(t2);
  }
  vi() {
    this.Ai();
  }
  Vi(t2) {
    this.Pi(t2);
  }
  Si(t2) {
    this.bi(t2);
  }
};
var Mr = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.Di = e + "://" + t2.host, this.Ci = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  Ni(t2, e, n, s) {
    const i = this.xi(t2, e);
    $("RestConnection", "Sending: ", i, n);
    const r = {};
    return this.ki(r, s), this.$i(t2, i, r, n).then((t3) => ($("RestConnection", "Received: ", t3), t3), (e2) => {
      throw F2("RestConnection", `${t2} failed with error: `, e2, "url: ", i, "request:", n), e2;
    });
  }
  Oi(t2, e, n, s) {
    return this.Ni(t2, e, n, s);
  }
  ki(t2, e) {
    if (t2["X-Goog-Api-Client"] = "gl-js/ fire/" + V2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e)
      for (const n in e.authHeaders)
        e.authHeaders.hasOwnProperty(n) && (t2[n] = e.authHeaders[n]);
  }
  xi(t2, e) {
    const n = Or[t2];
    return `${this.Di}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  $i(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              $("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              $("Connection", 'RPC "' + t2 + '" timed out'), r(new C2(D2.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if ($("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(D2).indexOf(e4) >= 0 ? e4 : D2.UNKNOWN;
                  }(t3.status);
                  r(new C2(e3, t3.message));
                } else
                  r(new C2(D2.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new C2(D2.UNAVAILABLE, "Connection failed."));
              break;
            default:
              L2();
          }
        } finally {
          $("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const c = JSON.stringify(s);
      o.send(e, "POST", c, n, 15);
    });
  }
  Fi(t2, e) {
    const n = [this.Di, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], s = createWebChannelTransport(), i = getStatEventTarget(), r = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (r.xmlHttpFactory = new FetchXmlHttpFactory({})), this.ki(r.initMessageHeaders, e), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (r.httpHeadersOverwriteParam = "$httpHeaders");
    const o = n.join("");
    $("Connection", "Creating WebChannel: " + o, r);
    const c = s.createWebChannel(o, r);
    let u = false, _ = false;
    const m = new Fr({
      Ei: (t3) => {
        _ ? $("Connection", "Not sending because WebChannel is closed:", t3) : (u || ($("Connection", "Opening WebChannel transport."), c.open(), u = true), $("Connection", "WebChannel sending:", t3), c.send(t3));
      },
      Ti: () => c.close()
    }), g = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return g(c, WebChannel.EventType.OPEN, () => {
      _ || $("Connection", "WebChannel transport opened.");
    }), g(c, WebChannel.EventType.CLOSE, () => {
      _ || (_ = true, $("Connection", "WebChannel transport closed"), m.Vi());
    }), g(c, WebChannel.EventType.ERROR, (t3) => {
      _ || (_ = true, F2("Connection", "WebChannel transport errored:", t3), m.Vi(new C2(D2.UNAVAILABLE, "The operation could not be completed")));
    }), g(c, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!_) {
        const n2 = t3.data[0];
        B2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          $("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = Ye[t5];
            if (e4 !== void 0)
              return tn(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = D2.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), _ = true, m.Vi(new C2(e3, n3)), c.close();
        } else
          $("Connection", "WebChannel received:", n2), m.Si(n2);
      }
    }), g(i, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? $("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && $("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      m.vi();
    }, 0), m;
  }
};
function Lr() {
  return typeof window != "undefined" ? window : null;
}
function Br() {
  return typeof document != "undefined" ? document : null;
}
function Ur(t2) {
  return new Vn(t2, true);
}
var qr = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Se = t2, this.timerId = e, this.Mi = n, this.Li = s, this.Bi = i, this.Ui = 0, this.qi = null, this.Ki = Date.now(), this.reset();
  }
  reset() {
    this.Ui = 0;
  }
  ji() {
    this.Ui = this.Bi;
  }
  Qi(t2) {
    this.cancel();
    const e = Math.floor(this.Ui + this.Wi()), n = Math.max(0, Date.now() - this.Ki), s = Math.max(0, e - n);
    s > 0 && $("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.Ui} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.qi = this.Se.enqueueAfterDelay(this.timerId, s, () => (this.Ki = Date.now(), t2())), this.Ui *= this.Li, this.Ui < this.Mi && (this.Ui = this.Mi), this.Ui > this.Bi && (this.Ui = this.Bi);
  }
  Gi() {
    this.qi !== null && (this.qi.skipDelay(), this.qi = null);
  }
  cancel() {
    this.qi !== null && (this.qi.cancel(), this.qi = null);
  }
  Wi() {
    return (Math.random() - 0.5) * this.Ui;
  }
};
var Kr = class {
  constructor(t2, e, n, s, i, r) {
    this.Se = t2, this.zi = n, this.Hi = s, this.Ji = i, this.listener = r, this.state = 0, this.Yi = 0, this.Xi = null, this.stream = null, this.Zi = new qr(t2, e);
  }
  tr() {
    return this.state === 1 || this.state === 2 || this.state === 4;
  }
  er() {
    return this.state === 2;
  }
  start() {
    this.state !== 3 ? this.auth() : this.nr();
  }
  async stop() {
    this.tr() && await this.close(0);
  }
  sr() {
    this.state = 0, this.Zi.reset();
  }
  ir() {
    this.er() && this.Xi === null && (this.Xi = this.Se.enqueueAfterDelay(this.zi, 6e4, () => this.rr()));
  }
  cr(t2) {
    this.ur(), this.stream.send(t2);
  }
  async rr() {
    if (this.er())
      return this.close(0);
  }
  ur() {
    this.Xi && (this.Xi.cancel(), this.Xi = null);
  }
  async close(t2, e) {
    this.ur(), this.Zi.cancel(), this.Yi++, t2 !== 3 ? this.Zi.reset() : e && e.code === D2.RESOURCE_EXHAUSTED ? (O2(e.toString()), O2("Using maximum backoff delay to prevent overloading the backend."), this.Zi.ji()) : e && e.code === D2.UNAUTHENTICATED && this.Ji.invalidateToken(), this.stream !== null && (this.ar(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Ri(e);
  }
  ar() {
  }
  auth() {
    this.state = 1;
    const t2 = this.hr(this.Yi), e = this.Yi;
    this.Ji.getToken().then((t3) => {
      this.Yi === e && this.lr(t3);
    }, (e2) => {
      t2(() => {
        const t3 = new C2(D2.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.dr(t3);
      });
    });
  }
  lr(t2) {
    const e = this.hr(this.Yi);
    this.stream = this.wr(t2), this.stream.Ii(() => {
      e(() => (this.state = 2, this.listener.Ii()));
    }), this.stream.Ri((t3) => {
      e(() => this.dr(t3));
    }), this.stream.onMessage((t3) => {
      e(() => this.onMessage(t3));
    });
  }
  nr() {
    this.state = 4, this.Zi.Qi(async () => {
      this.state = 0, this.start();
    });
  }
  dr(t2) {
    return $("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(3, t2);
  }
  hr(t2) {
    return (e) => {
      this.Se.enqueueAndForget(() => this.Yi === t2 ? e() : ($("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var jr = class extends Kr {
  constructor(t2, e, n, s, i) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", e, n, i), this.R = s;
  }
  wr(t2) {
    return this.Hi.Fi("Listen", t2);
  }
  onMessage(t2) {
    this.Zi.reset();
    const e = jn(this.R, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return z2.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? z2.min() : e2.readTime ? Nn(e2.readTime) : z2.min();
    }(t2);
    return this.listener._r(e, n);
  }
  mr(t2) {
    const e = {};
    e.database = Ln(this.R), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = Ft(s) ? {
        documents: zn(t3, s)
      } : {
        query: Hn(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = Dn(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(z2.min()) > 0 && (n2.readTime = Sn(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.R, t2);
    const n = Yn(this.R, t2);
    n && (e.labels = n), this.cr(e);
  }
  gr(t2) {
    const e = {};
    e.database = Ln(this.R), e.removeTarget = t2, this.cr(e);
  }
};
var Qr = class extends Kr {
  constructor(t2, e, n, s, i) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", e, n, i), this.R = s, this.yr = false;
  }
  get pr() {
    return this.yr;
  }
  start() {
    this.yr = false, this.lastStreamToken = void 0, super.start();
  }
  ar() {
    this.yr && this.Er([]);
  }
  wr(t2) {
    return this.Hi.Fi("Write", t2);
  }
  onMessage(t2) {
    if (B2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.yr) {
      this.Zi.reset();
      const e = Gn(t2.writeResults, t2.commitTime), n = Nn(t2.commitTime);
      return this.listener.Tr(n, e);
    }
    return B2(!t2.writeResults || t2.writeResults.length === 0), this.yr = true, this.listener.Ir();
  }
  Ar() {
    const t2 = {};
    t2.database = Ln(this.R), this.cr(t2);
  }
  Er(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => Qn(this.R, t3))
    };
    this.cr(e);
  }
};
var Wr = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.credentials = t2, this.Hi = e, this.R = n, this.Rr = false;
  }
  Pr() {
    if (this.Rr)
      throw new C2(D2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  Ni(t2, e, n) {
    return this.Pr(), this.credentials.getToken().then((s) => this.Hi.Ni(t2, e, n, s)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === D2.UNAUTHENTICATED && this.credentials.invalidateToken(), t3) : new C2(D2.UNKNOWN, t3.toString());
    });
  }
  Oi(t2, e, n) {
    return this.Pr(), this.credentials.getToken().then((s) => this.Hi.Oi(t2, e, n, s)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === D2.UNAUTHENTICATED && this.credentials.invalidateToken(), t3) : new C2(D2.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.Rr = true;
  }
};
var Gr = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.br = 0, this.vr = null, this.Vr = true;
  }
  Sr() {
    this.br === 0 && (this.Dr("Unknown"), this.vr = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.vr = null, this.Cr("Backend didn't respond within 10 seconds."), this.Dr("Offline"), Promise.resolve())));
  }
  Nr(t2) {
    this.state === "Online" ? this.Dr("Unknown") : (this.br++, this.br >= 1 && (this.kr(), this.Cr(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.Dr("Offline")));
  }
  set(t2) {
    this.kr(), this.br = 0, t2 === "Online" && (this.Vr = false), this.Dr(t2);
  }
  Dr(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  Cr(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.Vr ? (O2(e), this.Vr = false) : $("OnlineStateTracker", e);
  }
  kr() {
    this.vr !== null && (this.vr.cancel(), this.vr = null);
  }
};
var zr = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.$r = [], this.Or = new Map(), this.Fr = new Set(), this.Mr = [], this.Lr = i, this.Lr.di((t3) => {
      n.enqueueAndForget(async () => {
        so(this) && ($("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = U2(t4);
          e2.Fr.add(4), await Jr(e2), e2.Br.set("Unknown"), e2.Fr.delete(4), await Hr(e2);
        }(this));
      });
    }), this.Br = new Gr(n, s);
  }
};
async function Hr(t2) {
  if (so(t2))
    for (const e of t2.Mr)
      await e(true);
}
async function Jr(t2) {
  for (const e of t2.Mr)
    await e(false);
}
function Yr(t2, e) {
  const n = U2(t2);
  n.Or.has(e.targetId) || (n.Or.set(e.targetId, e), no(n) ? eo(n) : To(n).er() && Zr(n, e));
}
function Xr(t2, e) {
  const n = U2(t2), s = To(n);
  n.Or.delete(e), s.er() && to(n, e), n.Or.size === 0 && (s.er() ? s.ir() : so(n) && n.Br.set("Unknown"));
}
function Zr(t2, e) {
  t2.Ur.q(e.targetId), To(t2).mr(e);
}
function to(t2, e) {
  t2.Ur.q(e), To(t2).gr(e);
}
function eo(t2) {
  t2.Ur = new An({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    lt: (e) => t2.Or.get(e) || null
  }), To(t2).start(), t2.Br.Sr();
}
function no(t2) {
  return so(t2) && !To(t2).tr() && t2.Or.size > 0;
}
function so(t2) {
  return U2(t2).Fr.size === 0;
}
function io(t2) {
  t2.Ur = void 0;
}
async function ro(t2) {
  t2.Or.forEach((e, n) => {
    Zr(t2, e);
  });
}
async function oo(t2, e) {
  io(t2), no(t2) ? (t2.Br.Nr(e), eo(t2)) : t2.Br.set("Unknown");
}
async function co(t2, e, n) {
  if (t2.Br.set("Online"), e instanceof Tn && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.Or.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.Or.delete(s), t3.Ur.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      $("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await uo(t2, n2);
    }
  else if (e instanceof pn ? t2.Ur.X(e) : e instanceof En ? t2.Ur.rt(e) : t2.Ur.et(e), !n.isEqual(z2.min()))
    try {
      const e2 = await er(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.Ur.ut(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.Or.get(s);
            i && t3.Or.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.Or.get(e4);
          if (!n3)
            return;
          t3.Or.set(e4, n3.withResumeToken(st.EMPTY_BYTE_STRING, n3.snapshotVersion)), to(t3, e4);
          const s = new Gs(n3.target, e4, 1, n3.sequenceNumber);
          Zr(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      $("RemoteStore", "Failed to raise snapshot:", e2), await uo(t2, e2);
    }
}
async function uo(t2, e, n) {
  if (!Ms(e))
    throw e;
  t2.Fr.add(1), await Jr(t2), t2.Br.set("Offline"), n || (n = () => er(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    $("RemoteStore", "Retrying IndexedDB access"), await n(), t2.Fr.delete(1), await Hr(t2);
  });
}
function ao(t2, e) {
  return e().catch((n) => uo(t2, n, e));
}
async function ho(t2) {
  const e = U2(t2), n = Io(e);
  let s = e.$r.length > 0 ? e.$r[e.$r.length - 1].batchId : -1;
  for (; lo(e); )
    try {
      const t3 = await ir(e.localStore, s);
      if (t3 === null) {
        e.$r.length === 0 && n.ir();
        break;
      }
      s = t3.batchId, fo(e, t3);
    } catch (t3) {
      await uo(e, t3);
    }
  wo(e) && _o(e);
}
function lo(t2) {
  return so(t2) && t2.$r.length < 10;
}
function fo(t2, e) {
  t2.$r.push(e);
  const n = Io(t2);
  n.er() && n.pr && n.Er(e.mutations);
}
function wo(t2) {
  return so(t2) && !Io(t2).tr() && t2.$r.length > 0;
}
function _o(t2) {
  Io(t2).start();
}
async function mo(t2) {
  Io(t2).Ar();
}
async function go(t2) {
  const e = Io(t2);
  for (const n of t2.$r)
    e.Er(n.mutations);
}
async function yo(t2, e, n) {
  const s = t2.$r.shift(), i = Ws.from(s, e, n);
  await ao(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await ho(t2);
}
async function po(t2, e) {
  e && Io(t2).pr && await async function(t3, e2) {
    if (n = e2.code, Ze(n) && n !== D2.ABORTED) {
      const n2 = t3.$r.shift();
      Io(t3).sr(), await ao(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await ho(t3);
    }
    var n;
  }(t2, e), wo(t2) && _o(t2);
}
async function Eo(t2, e) {
  const n = U2(t2);
  e ? (n.Fr.delete(2), await Hr(n)) : e || (n.Fr.add(2), await Jr(n), n.Br.set("Unknown"));
}
function To(t2) {
  return t2.qr || (t2.qr = function(t3, e, n) {
    const s = U2(t3);
    return s.Pr(), new jr(e, s.Hi, s.credentials, s.R, n);
  }(t2.datastore, t2.asyncQueue, {
    Ii: ro.bind(null, t2),
    Ri: oo.bind(null, t2),
    _r: co.bind(null, t2)
  }), t2.Mr.push(async (e) => {
    e ? (t2.qr.sr(), no(t2) ? eo(t2) : t2.Br.set("Unknown")) : (await t2.qr.stop(), io(t2));
  })), t2.qr;
}
function Io(t2) {
  return t2.Kr || (t2.Kr = function(t3, e, n) {
    const s = U2(t3);
    return s.Pr(), new Qr(e, s.Hi, s.credentials, s.R, n);
  }(t2.datastore, t2.asyncQueue, {
    Ii: mo.bind(null, t2),
    Ri: po.bind(null, t2),
    Ir: go.bind(null, t2),
    Tr: yo.bind(null, t2)
  }), t2.Mr.push(async (e) => {
    e ? (t2.Kr.sr(), await ho(t2)) : (await t2.Kr.stop(), t2.$r.length > 0 && ($("RemoteStore", `Stopping write stream with ${t2.$r.length} pending writes`), t2.$r = []));
  })), t2.Kr;
}
var Ao = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new Ns(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new Ao(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new C2(D2.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function Ro(t2, e) {
  if (O2("AsyncQueue", `${e}: ${t2}`), Ms(t2))
    return new C2(D2.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var Po = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || wt.comparator(e.key, n.key) : (t3, e) => wt.comparator(t3.key, e.key), this.keyedMap = hn(), this.sortedSet = new en(this.comparator);
  }
  static emptySet(t2) {
    return new Po(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof Po))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new Po();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var bo = class {
  constructor() {
    this.jr = new en(wt.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.jr.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.jr = this.jr.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.jr = this.jr.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.jr = this.jr.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.jr = this.jr.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.jr = this.jr.remove(e) : t2.type === 1 && n.type === 2 ? this.jr = this.jr.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.jr = this.jr.insert(e, {
      type: 2,
      doc: t2.doc
    }) : L2() : this.jr = this.jr.insert(e, t2);
  }
  Qr() {
    const t2 = [];
    return this.jr.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var vo = class {
  constructor(t2, e, n, s, i, r, o, c) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = c;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new vo(t2, e, Po.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && le(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var Vo = class {
  constructor() {
    this.Wr = void 0, this.listeners = [];
  }
};
var So = class {
  constructor() {
    this.queries = new xi((t2) => fe(t2), le), this.onlineState = "Unknown", this.Gr = new Set();
  }
};
async function Do(t2, e) {
  const n = U2(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Vo()), i)
    try {
      r.Wr = await n.onListen(s);
    } catch (t3) {
      const n2 = Ro(t3, `Initialization of query '${de(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.zr(n.onlineState), r.Wr) {
    e.Hr(r.Wr) && ko(n);
  }
}
async function Co(t2, e) {
  const n = U2(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function No(t2, e) {
  const n = U2(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.Hr(t3) && (s = true);
      i.Wr = t3;
    }
  }
  s && ko(n);
}
function xo(t2, e, n) {
  const s = U2(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function ko(t2) {
  t2.Gr.forEach((t3) => {
    t3.next();
  });
}
var $o = class {
  constructor(t2, e, n) {
    this.query = t2, this.Jr = e, this.Yr = false, this.Xr = null, this.onlineState = "Unknown", this.options = n || {};
  }
  Hr(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new vo(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.Yr ? this.Zr(t2) && (this.Jr.next(t2), e = true) : this.eo(t2, this.onlineState) && (this.no(t2), e = true), this.Xr = t2, e;
  }
  onError(t2) {
    this.Jr.error(t2);
  }
  zr(t2) {
    this.onlineState = t2;
    let e = false;
    return this.Xr && !this.Yr && this.eo(this.Xr, t2) && (this.no(this.Xr), e = true), e;
  }
  eo(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.so || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  Zr(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.Xr && this.Xr.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  no(t2) {
    t2 = vo.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.Yr = true, this.Jr.next(t2);
  }
};
var Oo = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  io() {
    return "metadata" in this.payload;
  }
};
var Fo = class {
  constructor(t2) {
    this.R = t2;
  }
  Un(t2) {
    return On(this.R, t2);
  }
  qn(t2) {
    return t2.metadata.exists ? qn(this.R, t2.document, false) : Ct.newNoDocument(this.Un(t2.metadata.name), this.Kn(t2.metadata.readTime));
  }
  Kn(t2) {
    return Nn(t2);
  }
};
var Mo = class {
  constructor(t2, e, n) {
    this.ro = t2, this.localStore = e, this.R = n, this.queries = [], this.documents = [], this.progress = Lo(t2);
  }
  oo(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    return t2.payload.namedQuery ? this.queries.push(t2.payload.namedQuery) : t2.payload.documentMetadata ? (this.documents.push({
      metadata: t2.payload.documentMetadata
    }), t2.payload.documentMetadata.exists || ++e) : t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e), e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  co(t2) {
    const e = new Map(), n = new Fo(this.R);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.Un(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || wn()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await lr(this.localStore, new Fo(this.R), this.documents, this.ro.id), e = this.co(this.documents);
    for (const t3 of this.queries)
      await fr(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", new Gi(Object.assign({}, this.progress), t2);
  }
};
function Lo(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var Bo = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Uo = class {
  constructor(t2) {
    this.key = t2;
  }
};
var qo = class {
  constructor(t2, e) {
    this.query = t2, this.uo = e, this.ao = null, this.current = false, this.ho = wn(), this.mutatedKeys = wn(), this.lo = _e(t2), this.fo = new Po(this.lo);
  }
  get wo() {
    return this.uo;
  }
  _o(t2, e) {
    const n = e ? e.mo : new bo(), s = e ? e.fo : this.fo;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const c = se(this.query) && s.size === this.query.limit ? s.last() : null, u = ie(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const a = s.get(t3), h = we(this.query, e2) ? e2 : null, l2 = !!a && this.mutatedKeys.has(a.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (a && h) {
        a.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.yo(a, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (c && this.lo(h, c) > 0 || u && this.lo(h, u) < 0) && (o = true));
      } else
        !a && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : a && !h && (n.track({
          type: 1,
          doc: a
        }), d = true, (c || u) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), se(this.query) || ie(this.query))
      for (; r.size > this.query.limit; ) {
        const t3 = se(this.query) ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      fo: r,
      mo: n,
      Nn: o,
      mutatedKeys: i
    };
  }
  yo(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.fo;
    this.fo = t2.fo, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.mo.Qr();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return L2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.lo(t3.doc, e2.doc)), this.po(n);
    const r = e ? this.Eo() : [], o = this.ho.size === 0 && this.current ? 1 : 0, c = o !== this.ao;
    if (this.ao = o, i.length !== 0 || c) {
      return {
        snapshot: new vo(this.query, t2.fo, s, i, t2.mutatedKeys, o === 0, c, false),
        To: r
      };
    }
    return {
      To: r
    };
  }
  zr(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      fo: this.fo,
      mo: new bo(),
      mutatedKeys: this.mutatedKeys,
      Nn: false
    }, false)) : {
      To: []
    };
  }
  Io(t2) {
    return !this.uo.has(t2) && (!!this.fo.has(t2) && !this.fo.get(t2).hasLocalMutations);
  }
  po(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.uo = this.uo.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.uo = this.uo.delete(t3)), this.current = t2.current);
  }
  Eo() {
    if (!this.current)
      return [];
    const t2 = this.ho;
    this.ho = wn(), this.fo.forEach((t3) => {
      this.Io(t3.key) && (this.ho = this.ho.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.ho.has(t3) || e.push(new Uo(t3));
    }), this.ho.forEach((n) => {
      t2.has(n) || e.push(new Bo(n));
    }), e;
  }
  Ao(t2) {
    this.uo = t2.Bn, this.ho = wn();
    const e = this._o(t2.documents);
    return this.applyChanges(e, true);
  }
  Ro() {
    return vo.fromInitialDocuments(this.query, this.fo, this.mutatedKeys, this.ao === 0);
  }
};
var Ko = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var jo = class {
  constructor(t2) {
    this.key = t2, this.Po = false;
  }
};
var Qo = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.bo = {}, this.vo = new xi((t3) => fe(t3), le), this.Vo = new Map(), this.So = new Set(), this.Do = new en(wt.comparator), this.Co = new Map(), this.No = new wr(), this.xo = {}, this.ko = new Map(), this.$o = Ti.Yt(), this.onlineState = "Unknown", this.Oo = void 0;
  }
  get isPrimaryClient() {
    return this.Oo === true;
  }
};
async function Wo(t2, e) {
  const n = Tc2(t2);
  let s, i;
  const r = n.vo.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.Ro();
  else {
    const t3 = await rr(n.localStore, ae(e)), r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await Go(n, e, s, r2 === "current"), n.isPrimaryClient && Yr(n.remoteStore, t3);
  }
  return i;
}
async function Go(t2, e, n, s) {
  t2.Fo = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view._o(n3);
    i2.Nn && (i2 = await cr(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view._o(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return oc2(t3, e3.targetId, o2.To), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await cr(t2.localStore, e, true), r = new qo(e, i.Bn), o = r._o(i.documents), c = yn.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), u = r.applyChanges(o, t2.isPrimaryClient, c);
  oc2(t2, n, u.To);
  const a = new Ko(e, n, r);
  return t2.vo.set(e, a), t2.Vo.has(n) ? t2.Vo.get(n).push(e) : t2.Vo.set(n, [e]), u.snapshot;
}
async function zo(t2, e) {
  const n = U2(t2), s = n.vo.get(e), i = n.Vo.get(s.targetId);
  if (i.length > 1)
    return n.Vo.set(s.targetId, i.filter((t3) => !le(t3, e))), void n.vo.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await or(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), Xr(n.remoteStore, s.targetId), ic2(n, s.targetId);
    }).catch(bi);
  } else
    ic2(n, s.targetId), await or(n.localStore, s.targetId, true);
}
async function Ho(t2, e, n) {
  const s = Ic2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = U2(t4), s2 = G.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), wn());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.Mn.pn(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = Be(t6, r.get(t6.key));
          e3 != null && o.push(new je(t6.key, e3, Dt(e3.value.mapValue), $e.exists(true)));
        }
        return n2._n.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.xo[t4.currentUser.toKey()];
      s2 || (s2 = new en(j));
      s2 = s2.insert(e2, n2), t4.xo[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await ac2(s, t3.changes), await ho(s.remoteStore);
  } catch (t3) {
    const e2 = Ro(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function Jo(t2, e) {
  const n = U2(t2);
  try {
    const t3 = await nr(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.Co.get(e2);
      s && (B2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.Po = true : t4.modifiedDocuments.size > 0 ? B2(s.Po) : t4.removedDocuments.size > 0 && (B2(s.Po), s.Po = false));
    }), await ac2(n, t3, e);
  } catch (t3) {
    await bi(t3);
  }
}
function Yo(t2, e, n) {
  const s = U2(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.vo.forEach((n2, s2) => {
      const i = s2.view.zr(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = U2(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.zr(e2) && (s2 = true);
      }), s2 && ko(n2);
    }(s.eventManager, e), t3.length && s.bo._r(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function Xo(t2, e, n) {
  const s = U2(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.Co.get(e), r = i && i.key;
  if (r) {
    let t3 = new en(wt.comparator);
    t3 = t3.insert(r, Ct.newNoDocument(r, z2.min()));
    const n2 = wn().add(r), i2 = new gn(z2.min(), new Map(), new rn(j), t3, n2);
    await Jo(s, i2), s.Do = s.Do.remove(r), s.Co.delete(e), uc2(s);
  } else
    await or(s.localStore, e, false).then(() => ic2(s, e, n)).catch(bi);
}
async function Zo(t2, e) {
  const n = U2(t2), s = e.batch.batchId;
  try {
    const t3 = await tr(n.localStore, e);
    sc2(n, s, null), nc2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await ac2(n, t3);
  } catch (t3) {
    await bi(t3);
  }
}
async function tc2(t2, e, n) {
  const s = U2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = U2(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2._n.lookupMutationBatch(t5, e2).next((e3) => (B2(e3 !== null), s2 = e3.keys(), n2._n.removeMutationBatch(t5, e3))).next(() => n2._n.performConsistencyCheck(t5)).next(() => n2.Mn.pn(t5, s2));
      });
    }(s.localStore, e);
    sc2(s, e, n), nc2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await ac2(s, t3);
  } catch (n2) {
    await bi(n2);
  }
}
async function ec2(t2, e) {
  const n = U2(t2);
  so(n.remoteStore) || $("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = U2(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2._n.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.ko.get(t3) || [];
    s.push(e), n.ko.set(t3, s);
  } catch (t3) {
    const n2 = Ro(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function nc2(t2, e) {
  (t2.ko.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.ko.delete(e);
}
function sc2(t2, e, n) {
  const s = U2(t2);
  let i = s.xo[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.xo[s.currentUser.toKey()] = i;
  }
}
function ic2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.Vo.get(e))
    t2.vo.delete(s), n && t2.bo.Mo(s, n);
  if (t2.Vo.delete(e), t2.isPrimaryClient) {
    t2.No.Zn(e).forEach((e2) => {
      t2.No.containsKey(e2) || rc2(t2, e2);
    });
  }
}
function rc2(t2, e) {
  t2.So.delete(e.path.canonicalString());
  const n = t2.Do.get(e);
  n !== null && (Xr(t2.remoteStore, n), t2.Do = t2.Do.remove(e), t2.Co.delete(n), uc2(t2));
}
function oc2(t2, e, n) {
  for (const s of n)
    if (s instanceof Bo)
      t2.No.addReference(s.key, e), cc2(t2, s);
    else if (s instanceof Uo) {
      $("SyncEngine", "Document no longer in limbo: " + s.key), t2.No.removeReference(s.key, e);
      t2.No.containsKey(s.key) || rc2(t2, s.key);
    } else
      L2();
}
function cc2(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.Do.get(n) || t2.So.has(s) || ($("SyncEngine", "New document in limbo: " + n), t2.So.add(s), uc2(t2));
}
function uc2(t2) {
  for (; t2.So.size > 0 && t2.Do.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.So.values().next().value;
    t2.So.delete(e);
    const n = new wt(Z2.fromString(e)), s = t2.$o.next();
    t2.Co.set(s, new jo(n)), t2.Do = t2.Do.insert(n, s), Yr(t2.remoteStore, new Gs(ae(ne(n.path)), s, 2, S2.o));
  }
}
async function ac2(t2, e, n) {
  const s = U2(t2), i = [], r = [], o = [];
  s.vo.isEmpty() || (s.vo.forEach((t3, c) => {
    o.push(s.Fo(c, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(c.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = Hi.vn(c.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.bo._r(i), await async function(t3, e2) {
    const n2 = U2(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => xs.forEach(e2, (e3) => xs.forEach(e3.Pn, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => xs.forEach(e3.bn, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!Ms(t4))
        throw t4;
      $("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.kn.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.kn = n2.kn.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function hc2(t2, e) {
  const n = U2(t2);
  if (!n.currentUser.isEqual(e)) {
    $("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await Zi(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.ko.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new C2(D2.CANCELLED, e2));
        });
      }), t4.ko.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await ac2(n, t3.Ln);
  }
}
function lc2(t2, e) {
  const n = U2(t2), s = n.Co.get(e);
  if (s && s.Po)
    return wn().add(s.key);
  {
    let t3 = wn();
    const s2 = n.Vo.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.vo.get(e2);
      t3 = t3.unionWith(s3.view.wo);
    }
    return t3;
  }
}
async function fc2(t2, e) {
  const n = U2(t2), s = await cr(n.localStore, e.query, true), i = e.view.Ao(s);
  return n.isPrimaryClient && oc2(n, e.targetId, i.To), i;
}
async function dc2(t2) {
  const e = U2(t2);
  return ar(e.localStore).then((t3) => ac2(e, t3));
}
async function wc2(t2, e, n, s) {
  const i = U2(t2), r = await function(t3, e2) {
    const n2 = U2(t3), s2 = U2(n2._n);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.Qt(t4, e2).next((e3) => e3 ? n2.Mn.pn(t4, e3) : xs.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await ho(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (sc2(i, e, s || null), nc2(i, e), function(t3, e2) {
    U2(U2(t3)._n).Gt(e2);
  }(i.localStore, e)) : L2(), await ac2(i, r)) : $("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function _c(t2, e) {
  const n = U2(t2);
  if (Tc2(n), Ic2(n), e === true && n.Oo !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await mc2(n, t3.toArray());
    n.Oo = true, await Eo(n.remoteStore, true);
    for (const t4 of e2)
      Yr(n.remoteStore, t4);
  } else if (e === false && n.Oo !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.Vo.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (ic2(n, i), or(n.localStore, i, true))), Xr(n.remoteStore, i);
    }), await e2, await mc2(n, t3), function(t4) {
      const e3 = U2(t4);
      e3.Co.forEach((t5, n2) => {
        Xr(e3.remoteStore, n2);
      }), e3.No.ts(), e3.Co = new Map(), e3.Do = new en(wt.comparator);
    }(n), n.Oo = false, await Eo(n.remoteStore, false);
  }
}
async function mc2(t2, e, n) {
  const s = U2(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.Vo.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await rr(s.localStore, ae(n2[0]));
      for (const t4 of n2) {
        const e3 = s.vo.get(t4), n3 = await fc2(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await ur(s.localStore, t3);
      e2 = await rr(s.localStore, n3), await Go(s, gc2(n3), t3, false);
    }
    i.push(e2);
  }
  return s.bo._r(r), i;
}
function gc2(t2) {
  return ee(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function yc2(t2) {
  const e = U2(t2);
  return U2(U2(e.localStore).persistence).fn();
}
async function pc2(t2, e, n, s) {
  const i = U2(t2);
  if (i.Oo)
    $("SyncEngine", "Ignoring unexpected query state notification.");
  else if (i.Vo.has(e))
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await ar(i.localStore), s2 = gn.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await ac2(i, t3, s2);
        break;
      }
      case "rejected":
        await or(i.localStore, e, true), ic2(i, e, s);
        break;
      default:
        L2();
    }
}
async function Ec2(t2, e, n) {
  const s = Tc2(t2);
  if (s.Oo) {
    for (const t3 of e) {
      if (s.Vo.has(t3)) {
        $("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await ur(s.localStore, t3), n2 = await rr(s.localStore, e2);
      await Go(s, gc2(e2), n2.targetId, false), Yr(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.Vo.has(t3) && await or(s.localStore, t3, false).then(() => {
        Xr(s.remoteStore, t3), ic2(s, t3);
      }).catch(bi);
  }
}
function Tc2(t2) {
  const e = U2(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = Jo.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = lc2.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = Xo.bind(null, e), e.bo._r = No.bind(null, e.eventManager), e.bo.Mo = xo.bind(null, e.eventManager), e;
}
function Ic2(t2) {
  const e = U2(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = Zo.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = tc2.bind(null, e), e;
}
function Ac2(t2, e, n) {
  const s = U2(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = U2(t4), s3 = Nn(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.Ke.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), void n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2));
      n2._updateProgress(Lo(s2));
      const i = new Mo(s2, t3.localStore, e2.R);
      let r = await e2.Lo();
      for (; r; ) {
        const t4 = await i.oo(r);
        t4 && n2._updateProgress(t4), r = await e2.Lo();
      }
      const o = await i.complete();
      await ac2(t3, o.wn, void 0), await function(t4, e3) {
        const n3 = U2(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.Ke.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress);
    } catch (t4) {
      F2("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4);
    }
  })(s, e, n).then(() => {
    s.sharedClientState.notifyBundleLoaded();
  });
}
var Rc2 = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.R = Ur(t2.databaseInfo.databaseId), this.sharedClientState = this.Bo(t2), this.persistence = this.Uo(t2), await this.persistence.start(), this.gcScheduler = this.qo(t2), this.localStore = this.Ko(t2);
  }
  qo(t2) {
    return null;
  }
  Ko(t2) {
    return Xi(this.persistence, new Ji(), t2.initialUser, this.R);
  }
  Uo(t2) {
    return new Er(Ir.Ps, this.R);
  }
  Bo(t2) {
    return new xr();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var Pc2 = class extends Rc2 {
  constructor(t2, e, n) {
    super(), this.jo = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await hr(this.localStore), await this.jo.initialize(this, t2), await Ic2(this.jo.syncEngine), await ho(this.jo.remoteStore);
  }
  Ko(t2) {
    return Xi(this.persistence, new Ji(), t2.initialUser, this.R);
  }
  qo(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new Si(e, t2.asyncQueue);
  }
  Uo(t2) {
    const e = Wi(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? di.withCacheSize(this.cacheSizeBytes) : di.DEFAULT;
    return new Ki(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, Lr(), Br(), this.R, this.sharedClientState, !!this.forceOwnership);
  }
  Bo(t2) {
    return new xr();
  }
};
var bc2 = class extends Pc2 {
  constructor(t2, e) {
    super(t2, e, false), this.jo = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.jo.syncEngine;
    this.sharedClientState instanceof Nr && (this.sharedClientState.syncEngine = {
      ui: wc2.bind(null, e),
      ai: pc2.bind(null, e),
      hi: Ec2.bind(null, e),
      fn: yc2.bind(null, e),
      ci: dc2.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.He(async (t3) => {
      await _c(this.jo.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  Bo(t2) {
    const e = Lr();
    if (!Nr.gt(e))
      throw new C2(D2.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = Wi(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new Nr(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var vc2 = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => Yo(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = hc2.bind(null, this.syncEngine), await Eo(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new So();
  }
  createDatastore(t2) {
    const e = Ur(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new Mr(s));
    var s;
    return function(t3, e2, n2) {
      return new Wr(t3, e2, n2);
    }(t2.credentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => Yo(this.syncEngine, t3, 0), r = $r.gt() ? new $r() : new kr(), new zr(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const c = new Qo(t3, e2, n, s, i, r);
      return o && (c.Oo = true), c;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = U2(t2);
      $("RemoteStore", "RemoteStore shutting down."), e.Fr.add(5), await Jr(e), e.Lr.shutdown(), e.Br.set("Unknown");
    }(this.remoteStore);
  }
};
function Vc2(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var Sc2 = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.Qo(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.Qo(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  Wo() {
    this.muted = true;
  }
  Qo(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var Dc2 = class {
  constructor(t2, e) {
    this.Go = t2, this.R = e, this.metadata = new Ns(), this.buffer = new Uint8Array(), this.zo = new TextDecoder("utf-8"), this.Ho().then((t3) => {
      t3 && t3.io() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.Go.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async Lo() {
    return await this.getMetadata(), this.Ho();
  }
  async Ho() {
    const t2 = await this.Jo();
    if (t2 === null)
      return null;
    const e = this.zo.decode(t2), n = Number(e);
    isNaN(n) && this.Yo(`length string (${e}) is not valid number`);
    const s = await this.Xo(n);
    return new Oo(JSON.parse(s), t2.length + n);
  }
  Zo() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async Jo() {
    for (; this.Zo() < 0; ) {
      if (await this.tc())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.Zo();
    t2 < 0 && this.Yo("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async Xo(t2) {
    for (; this.buffer.length < t2; ) {
      await this.tc() && this.Yo("Reached the end of bundle when more is expected.");
    }
    const e = this.zo.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  Yo(t2) {
    throw this.Go.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async tc() {
    const t2 = await this.Go.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var Cc2 = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new C2(D2.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = U2(t3), s = Ln(n.R) + "/documents", i = {
        documents: e2.map((t4) => $n(n.R, t4))
      }, r = await n.Oi("BatchGetDocuments", s, i), o = new Map();
      r.forEach((t4) => {
        const e3 = Kn(n.R, t4);
        o.set(e3.key.toString(), e3);
      });
      const c = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        B2(!!e3), c.push(e3);
      }), c;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new ze(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = wt.fromPath(e);
      this.mutations.push(new He(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = U2(t3), s = Ln(n.R) + "/documents", i = {
        writes: e.map((t4) => Qn(n.R, t4))
      };
      await n.Ni("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw L2();
      e = z2.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new C2(D2.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? $e.updateTime(e) : $e.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(z2.min()))
        throw new C2(D2.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return $e.updateTime(e);
    }
    return $e.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var Nc2 = class {
  constructor(t2, e, n, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n, this.deferred = s, this.ec = 5, this.Zi = new qr(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.ec -= 1, this.nc();
  }
  nc() {
    this.Zi.Qi(async () => {
      const t2 = new Cc2(this.datastore), e = this.sc(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.ic(t3);
        }));
      }).catch((t3) => {
        this.ic(t3);
      });
    });
  }
  sc(t2) {
    try {
      const e = this.updateFunction(t2);
      return !lt(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  ic(t2) {
    this.ec > 0 && this.rc(t2) ? (this.ec -= 1, this.asyncQueue.enqueueAndForget(() => (this.nc(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  rc(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !Ze(e);
    }
    return false;
  }
};
var xc2 = class {
  constructor(t2, e, n) {
    this.credentials = t2, this.asyncQueue = e, this.databaseInfo = n, this.user = Ar.UNAUTHENTICATED, this.clientId = K2.u(), this.credentialListener = () => Promise.resolve(), this.credentials.setChangeListener(e, async (t3) => {
      $("FirestoreClient", "Received user=", t3.uid), await this.credentialListener(t3), this.user = t3;
    });
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      credentials: this.credentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.credentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new C2(D2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new Ns();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.credentials.removeChangeListener(), t2.resolve();
      } catch (e) {
        const n = Ro(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function kc2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), $("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await Zi(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function $c2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await Oc2(t2);
  $("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => async function(t4, e2) {
    const n2 = U2(t4);
    n2.asyncQueue.verifyOperationInProgress(), $("RemoteStore", "RemoteStore received new credentials");
    const s2 = so(n2);
    n2.Fr.add(3), await Jr(n2), s2 && n2.Br.set("Unknown"), await n2.remoteSyncer.handleCredentialChange(e2), n2.Fr.delete(3), await Hr(n2);
  }(e.remoteStore, t3)), t2.onlineComponents = e;
}
async function Oc2(t2) {
  return t2.offlineComponents || ($("FirestoreClient", "Using default OfflineComponentProvider"), await kc2(t2, new Rc2())), t2.offlineComponents;
}
async function Fc2(t2) {
  return t2.onlineComponents || ($("FirestoreClient", "Using default OnlineComponentProvider"), await $c2(t2, new vc2())), t2.onlineComponents;
}
function Mc2(t2) {
  return Oc2(t2).then((t3) => t3.persistence);
}
function Lc2(t2) {
  return Oc2(t2).then((t3) => t3.localStore);
}
function Bc2(t2) {
  return Fc2(t2).then((t3) => t3.remoteStore);
}
function Uc2(t2) {
  return Fc2(t2).then((t3) => t3.syncEngine);
}
async function qc2(t2) {
  const e = await Fc2(t2), n = e.eventManager;
  return n.onListen = Wo.bind(null, e.syncEngine), n.onUnlisten = zo.bind(null, e.syncEngine), n;
}
function Kc2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Mc2(t2), n = await Bc2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = U2(t3);
      return e2.Fr.delete(0), Hr(e2);
    }(n);
  });
}
function jc2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Mc2(t2), n = await Bc2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = U2(t3);
      e2.Fr.add(0), await Jr(e2), e2.Br.set("Offline");
    }(n);
  });
}
function Qc2(t2, e) {
  const n = new Ns();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = U2(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.Mn.mn(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new C2(D2.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = Ro(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await Lc2(t2), e, n)), n.promise;
}
function Wc2(t2, e, n = {}) {
  const s = new Ns();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Sc2({
      next: (r2) => {
        e2.enqueueAndForget(() => Co(t3, o));
        const c = r2.docs.has(n2);
        !c && r2.fromCache ? i.reject(new C2(D2.UNAVAILABLE, "Failed to get document because the client is offline.")) : c && r2.fromCache && s2 && s2.source === "server" ? i.reject(new C2(D2.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new $o(ne(n2.path), r, {
      includeMetadataChanges: true,
      so: true
    });
    return Do(t3, o);
  }(await qc2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Gc2(t2, e) {
  const n = new Ns();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await cr(t3, e2, true), i = new qo(e2, s.Bn), r = i._o(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = Ro(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await Lc2(t2), e, n)), n.promise;
}
function zc2(t2, e, n = {}) {
  const s = new Ns();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Sc2({
      next: (n3) => {
        e2.enqueueAndForget(() => Co(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new C2(D2.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new $o(n2, r, {
      includeMetadataChanges: true,
      so: true
    });
    return Do(t3, o);
  }(await qc2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Hc2(t2, e) {
  const n = new Sc2(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    U2(t3).Gr.add(e2), e2.next();
  }(await qc2(t2), n)), () => {
    n.Wo(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      U2(t3).Gr.delete(e2);
    }(await qc2(t2), n));
  };
}
function Jc2(t2, e) {
  const n = new Ns();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return Fc2(t3).then((t4) => t4.datastore);
    }(t2);
    new Nc2(t2.asyncQueue, s, e, n).run();
  }), n.promise;
}
function Yc2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new Dc2(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Vc2(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Vc2(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, Ur(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    Ac2(await Uc2(t2), i, s);
  });
}
function Xc2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = U2(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.Ke.getNamedQuery(t4, e2));
  }(await Lc2(t2), e));
}
var Zc2 = class {
  constructor(t2, e, n, s, i, r, o, c) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = c;
  }
};
var tu = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof tu && t2.projectId === this.projectId && t2.database === this.database;
  }
};
var eu = new Map();
var nu = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.authHeaders = {}, this.authHeaders.Authorization = `Bearer ${t2}`;
  }
};
var su = class {
  constructor() {
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  setChangeListener(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(Ar.UNAUTHENTICATED));
  }
  removeChangeListener() {
    this.changeListener = null;
  }
};
var iu = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  setChangeListener(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  removeChangeListener() {
    this.changeListener = null;
  }
};
var ru = class {
  constructor(t2) {
    this.currentUser = Ar.UNAUTHENTICATED, this.oc = new Ns(), this.cc = 0, this.forceRefresh = false, this.auth = null, this.asyncQueue = null, this.uc = () => {
      this.cc++, this.currentUser = this.ac(), this.oc.resolve(), this.changeListener && this.asyncQueue.enqueueRetryable(() => this.changeListener(this.currentUser));
    };
    const e = (t3) => {
      $("FirebaseCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.uc);
    };
    t2.onInit((t3) => e(t3)), setTimeout(() => {
      if (!this.auth) {
        const n = t2.getImmediate({
          optional: true
        });
        n ? e(n) : ($("FirebaseCredentialsProvider", "Auth not yet detected"), this.oc.resolve());
      }
    }, 0);
  }
  getToken() {
    const t2 = this.cc, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.cc !== t2 ? ($("FirebaseCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (B2(typeof e2.accessToken == "string"), new nu(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  setChangeListener(t2, e) {
    this.asyncQueue = t2, this.asyncQueue.enqueueRetryable(async () => {
      await this.oc.promise, await e(this.currentUser), this.changeListener = e;
    });
  }
  removeChangeListener() {
    this.auth && this.auth.removeAuthTokenListener(this.uc), this.changeListener = () => Promise.resolve();
  }
  ac() {
    const t2 = this.auth && this.auth.getUid();
    return B2(t2 === null || typeof t2 == "string"), new Ar(t2);
  }
};
var ou = class {
  constructor(t2, e, n) {
    this.hc = t2, this.lc = e, this.fc = n, this.type = "FirstParty", this.user = Ar.FIRST_PARTY;
  }
  get authHeaders() {
    const t2 = {
      "X-Goog-AuthUser": this.lc
    }, e = this.hc.auth.getAuthHeaderValueForFirstParty([]);
    return e && (t2.Authorization = e), this.fc && (t2["X-Goog-Iam-Authorization-Token"] = this.fc), t2;
  }
};
var cu = class {
  constructor(t2, e, n) {
    this.hc = t2, this.lc = e, this.fc = n;
  }
  getToken() {
    return Promise.resolve(new ou(this.hc, this.lc, this.fc));
  }
  setChangeListener(t2, e) {
    t2.enqueueRetryable(() => e(Ar.FIRST_PARTY));
  }
  removeChangeListener() {
  }
  invalidateToken() {
  }
};
function uu(t2, e, n) {
  if (!n)
    throw new C2(D2.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function au(t2) {
  if (!wt.isDocumentKey(t2))
    throw new C2(D2.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function hu(t2) {
  if (wt.isDocumentKey(t2))
    throw new C2(D2.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function lu(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor) {
          const e2 = /function\s+([^\s(]+)\s*\(/.exec(t3.constructor.toString());
          if (e2 && e2.length > 1)
            return e2[1];
        }
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : L2();
}
function fu(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new C2(D2.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = lu(t2);
      throw new C2(D2.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function du(t2, e) {
  if (e <= 0)
    throw new C2(D2.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var wu = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new C2(D2.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new C2(D2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, function(t3, e2, n, s) {
      if (e2 === true && s === true)
        throw new C2(D2.INVALID_ARGUMENT, `${t3} and ${n} cannot be used together.`);
    }("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var _u = class {
  constructor(t2, e) {
    this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new wu({}), this._settingsFrozen = false, t2 instanceof tu ? (this._databaseId = t2, this._credentials = new su()) : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new C2(D2.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new tu(t3.options.projectId);
    }(t2), this._credentials = new ru(e));
  }
  get app() {
    if (!this._app)
      throw new C2(D2.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new C2(D2.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new wu(t2), t2.credentials !== void 0 && (this._credentials = function(t3) {
      if (!t3)
        return new su();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return B2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new cu(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new C2(D2.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = eu.get(t2);
      e && ($("ComponentProvider", "Removing Datastore"), eu.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function mu(t2, e, n, s = {}) {
  const i = (t2 = fu(t2, _u))._getSettings();
  if (i.host !== "firestore.googleapis.com" && i.host !== e && F2("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, i), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    const e2 = createMockUserToken(s.mockUserToken), n2 = s.mockUserToken.sub || s.mockUserToken.user_id;
    if (!n2)
      throw new C2(D2.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
    t2._credentials = new iu(new nu(e2, new Ar(n2)));
  }
}
var gu = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new pu(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new gu(this.firestore, t2, this._key);
  }
};
var yu = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new yu(this.firestore, t2, this._query);
  }
};
var pu = class extends yu {
  constructor(t2, e, n) {
    super(t2, e, ne(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new gu(this.firestore, null, new wt(t2));
  }
  withConverter(t2) {
    return new pu(this.firestore, t2, this._path);
  }
};
function Eu(t2, e, ...n) {
  if (t2 = getModularInstance(t2), uu("collection", "path", e), t2 instanceof _u) {
    const s = Z2.fromString(e, ...n);
    return hu(s), new pu(t2, null, s);
  }
  {
    if (!(t2 instanceof gu || t2 instanceof pu))
      throw new C2(D2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = Z2.fromString(t2.path, ...n).child(Z2.fromString(e));
    return hu(s), new pu(t2.firestore, null, s);
  }
}
function Tu(t2, e) {
  if (t2 = fu(t2, _u), uu("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new C2(D2.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new yu(t2, null, function(t3) {
    return new te(Z2.emptyPath(), t3);
  }(e));
}
function Iu(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = K2.u()), uu("doc", "path", e), t2 instanceof _u) {
    const s = Z2.fromString(e, ...n);
    return au(s), new gu(t2, null, new wt(s));
  }
  {
    if (!(t2 instanceof gu || t2 instanceof pu))
      throw new C2(D2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(Z2.fromString(e, ...n));
    return au(s), new gu(t2.firestore, t2 instanceof pu ? t2.converter : null, new wt(s));
  }
}
function Au(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof gu || t2 instanceof pu) && (e instanceof gu || e instanceof pu) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function Ru(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof yu && e instanceof yu && (t2.firestore === e.firestore && le(t2._query, e._query) && t2.converter === e.converter);
}
var Pu = class {
  constructor() {
    this.dc = Promise.resolve(), this.wc = [], this._c = false, this.mc = [], this.gc = null, this.yc = false, this.Ec = false, this.Tc = [], this.Zi = new qr(this, "async_queue_retry"), this.Ic = () => {
      const t3 = Br();
      t3 && $("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.Zi.Gi();
    };
    const t2 = Br();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.Ic);
  }
  get isShuttingDown() {
    return this._c;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Ac(), this.Rc(t2);
  }
  enterRestrictedMode(t2) {
    if (!this._c) {
      this._c = true, this.Ec = t2 || false;
      const e = Br();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.Ic);
    }
  }
  enqueue(t2) {
    if (this.Ac(), this._c)
      return new Promise(() => {
      });
    const e = new Ns();
    return this.Rc(() => this._c && this.Ec ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.wc.push(t2), this.Pc()));
  }
  async Pc() {
    if (this.wc.length !== 0) {
      try {
        await this.wc[0](), this.wc.shift(), this.Zi.reset();
      } catch (t2) {
        if (!Ms(t2))
          throw t2;
        $("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.wc.length > 0 && this.Zi.Qi(() => this.Pc());
    }
  }
  Rc(t2) {
    const e = this.dc.then(() => (this.yc = true, t2().catch((t3) => {
      this.gc = t3, this.yc = false;
      throw O2("INTERNAL UNHANDLED ERROR: ", function(t4) {
        let e2 = t4.message || "";
        t4.stack && (e2 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e2;
      }(t3)), t3;
    }).then((t3) => (this.yc = false, t3))));
    return this.dc = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Ac(), this.Tc.indexOf(t2) > -1 && (e = 0);
    const s = Ao.createAndSchedule(this, t2, e, n, (t3) => this.bc(t3));
    return this.mc.push(s), s;
  }
  Ac() {
    this.gc && L2();
  }
  verifyOperationInProgress() {
  }
  async vc() {
    let t2;
    do {
      t2 = this.dc, await t2;
    } while (t2 !== this.dc);
  }
  Vc(t2) {
    for (const e of this.mc)
      if (e.timerId === t2)
        return true;
    return false;
  }
  Sc(t2) {
    return this.vc().then(() => {
      this.mc.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this.mc)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.vc();
    });
  }
  Dc(t2) {
    this.Tc.push(t2);
  }
  bc(t2) {
    const e = this.mc.indexOf(t2);
    this.mc.splice(e, 1);
  }
};
function bu(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var vu = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new Ns(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var Vu = -1;
var Su = class extends _u {
  constructor(t2, e) {
    super(t2, e), this.type = "firestore", this._queue = new Pu(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || xu(this), this._firestoreClient.terminate();
  }
};
function Du(e, n) {
  const s = _getProvider(e, "firestore-exp");
  if (s.isInitialized())
    throw new C2(D2.FAILED_PRECONDITION, "Firestore can only be initialized once per app.");
  if (n.cacheSizeBytes !== void 0 && n.cacheSizeBytes !== -1 && n.cacheSizeBytes < 1048576)
    throw new C2(D2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return s.initialize({
    options: n
  });
}
function Cu(n = getApp()) {
  return _getProvider(n, "firestore-exp").getImmediate();
}
function Nu(t2) {
  return t2._firestoreClient || xu(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function xu(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new Zc2(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new xc2(t2._credentials, t2._queue, s);
}
function ku(t2, e) {
  ju(t2 = fu(t2, Su));
  const n = Nu(t2), s = t2._freezeSettings(), i = new vc2();
  return Ou(n, i, new Pc2(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function $u(t2) {
  ju(t2 = fu(t2, Su));
  const e = Nu(t2), n = t2._freezeSettings(), s = new vc2();
  return Ou(e, s, new bc2(s, n.cacheSizeBytes));
}
function Ou(t2, e, n) {
  const s = new Ns();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await kc2(t2, n), await $c2(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === D2.FAILED_PRECONDITION || t4.code === D2.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function Fu(t2) {
  if (t2._initialized && !t2._terminated)
    throw new C2(D2.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new Ns();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!$s.gt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await $s.delete(e2);
      }(Wi(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function Mu(t2) {
  return function(t3) {
    const e = new Ns();
    return t3.asyncQueue.enqueueAndForget(async () => ec2(await Uc2(t3), e)), e.promise;
  }(Nu(t2 = fu(t2, Su)));
}
function Lu(t2) {
  return Kc2(Nu(t2 = fu(t2, Su)));
}
function Bu(t2) {
  return jc2(Nu(t2 = fu(t2, Su)));
}
function Uu(t2) {
  return _removeServiceInstance(t2.app, "firestore-exp"), t2._delete();
}
function qu(t2, e) {
  const n = Nu(t2 = fu(t2, Su)), s = new vu();
  return Yc2(n, t2._databaseId, e, s), s;
}
function Ku(t2, e) {
  return Xc2(Nu(t2 = fu(t2, Su)), e).then((e2) => e2 ? new yu(t2, null, e2.query) : null);
}
function ju(t2) {
  if (t2._initialized || t2._terminated)
    throw new C2(D2.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Qu = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new C2(D2.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new et(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function Wu() {
  return new Qu("__name__");
}
var Gu = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new Gu(st.fromBase64String(t2));
    } catch (t3) {
      throw new C2(D2.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new Gu(st.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var zu = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var Hu = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new C2(D2.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new C2(D2.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return j(this._lat, t2._lat) || j(this._long, t2._long);
  }
};
var Ju = /^__.*__$/;
var Yu = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new je(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new Ke(t2, this.data, e, this.fieldTransforms);
  }
};
var Xu = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new je(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function Zu(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L2();
  }
}
var ta2 = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.R = n, this.ignoreUndefinedProperties = s, i === void 0 && this.Cc(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get Nc() {
    return this.settings.Nc;
  }
  xc(t2) {
    return new ta2(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.R, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  kc(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.xc({
      path: n,
      $c: false
    });
    return s.Oc(t2), s;
  }
  Fc(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.xc({
      path: n,
      $c: false
    });
    return s.Cc(), s;
  }
  Mc(t2) {
    return this.xc({
      path: void 0,
      $c: true
    });
  }
  Lc(t2) {
    return Ea(t2, this.settings.methodName, this.settings.Bc || false, this.path, this.settings.Uc);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  Cc() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.Oc(this.path.get(t2));
  }
  Oc(t2) {
    if (t2.length === 0)
      throw this.Lc("Document fields must not be empty");
    if (Zu(this.Nc) && Ju.test(t2))
      throw this.Lc('Document fields cannot begin and end with "__"');
  }
};
var ea2 = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.R = n || Ur(t2);
  }
  qc(t2, e, n, s = false) {
    return new ta2({
      Nc: t2,
      methodName: e,
      Uc: n,
      path: et.emptyPath(),
      $c: false,
      Bc: s
    }, this.databaseId, this.R, this.ignoreUndefinedProperties);
  }
};
function na2(t2) {
  const e = t2._freezeSettings(), n = Ur(t2._databaseId);
  return new ea2(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function sa2(t2, e, n, s, i, r = {}) {
  const o = t2.qc(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  ma2("Data must be an object, but it was:", o, s);
  const c = wa(s, o);
  let u, a;
  if (r.merge)
    u = new nt(o.fieldMask), a = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = ga(e, s2, n);
      if (!o.contains(i2))
        throw new C2(D2.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      Ta(t3, i2) || t3.push(i2);
    }
    u = new nt(t3), a = o.fieldTransforms.filter((t4) => u.covers(t4.field));
  } else
    u = null, a = o.fieldTransforms;
  return new Yu(new St(c), u, a);
}
var ia2 = class extends zu {
  _toFieldTransform(t2) {
    if (t2.Nc !== 2)
      throw t2.Nc === 1 ? t2.Lc(`${this._methodName}() can only appear at the top level of your update data`) : t2.Lc(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof ia2;
  }
};
function ra2(t2, e, n) {
  return new ta2({
    Nc: 3,
    Uc: e.settings.Uc,
    methodName: t2._methodName,
    $c: n
  }, e.databaseId, e.R, e.ignoreUndefinedProperties);
}
var oa2 = class extends zu {
  _toFieldTransform(t2) {
    return new Ne(t2.path, new Re());
  }
  isEqual(t2) {
    return t2 instanceof oa2;
  }
};
var ca = class extends zu {
  constructor(t2, e) {
    super(t2), this.Kc = e;
  }
  _toFieldTransform(t2) {
    const e = ra2(this, t2, true), n = this.Kc.map((t3) => da2(t3, e)), s = new Pe(n);
    return new Ne(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var ua2 = class extends zu {
  constructor(t2, e) {
    super(t2), this.Kc = e;
  }
  _toFieldTransform(t2) {
    const e = ra2(this, t2, true), n = this.Kc.map((t3) => da2(t3, e)), s = new ve(n);
    return new Ne(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var aa2 = class extends zu {
  constructor(t2, e) {
    super(t2), this.jc = e;
  }
  _toFieldTransform(t2) {
    const e = new Se(t2.R, pe(t2.R, this.jc));
    return new Ne(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function ha2(t2, e, n, s) {
  const i = t2.qc(1, e, n);
  ma2("Data must be an object, but it was:", i, s);
  const r = [], o = St.empty();
  J2(s, (t3, s2) => {
    const c2 = pa2(e, t3, n);
    s2 = getModularInstance(s2);
    const u = i.Fc(c2);
    if (s2 instanceof ia2)
      r.push(c2);
    else {
      const t4 = da2(s2, u);
      t4 != null && (r.push(c2), o.set(c2, t4));
    }
  });
  const c = new nt(r);
  return new Xu(o, c, i.fieldTransforms);
}
function la2(t2, e, n, s, i, r) {
  const o = t2.qc(1, e, n), c = [ga(e, s, n)], u = [i];
  if (r.length % 2 != 0)
    throw new C2(D2.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    c.push(ga(e, r[t3])), u.push(r[t3 + 1]);
  const a = [], h = St.empty();
  for (let t3 = c.length - 1; t3 >= 0; --t3)
    if (!Ta(a, c[t3])) {
      const e2 = c[t3];
      let n2 = u[t3];
      n2 = getModularInstance(n2);
      const s2 = o.Fc(e2);
      if (n2 instanceof ia2)
        a.push(e2);
      else {
        const t4 = da2(n2, s2);
        t4 != null && (a.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new nt(a);
  return new Xu(h, l2, o.fieldTransforms);
}
function fa2(t2, e, n, s = false) {
  return da2(n, t2.qc(s ? 4 : 3, e));
}
function da2(t2, e) {
  if (_a(t2 = getModularInstance(t2)))
    return ma2("Unsupported field value:", e, t2), wa(t2, e);
  if (t2 instanceof zu)
    return function(t3, e2) {
      if (!Zu(e2.Nc))
        throw e2.Lc(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.Lc(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.$c && e.Nc !== 4)
      throw e.Lc("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = da2(i, e2.Mc(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return pe(e2.R, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = G.fromDate(t3);
      return {
        timestampValue: Sn(e2.R, n)
      };
    }
    if (t3 instanceof G) {
      const n = new G(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Sn(e2.R, n)
      };
    }
    if (t3 instanceof Hu)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof Gu)
      return {
        bytesValue: Dn(e2.R, t3._byteString)
      };
    if (t3 instanceof gu) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.Lc(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: xn(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.Lc(`Unsupported field value: ${lu(t3)}`);
  }(t2, e);
}
function wa(t2, e) {
  const n = {};
  return Y2(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : J2(t2, (t3, s) => {
    const i = da2(s, e.kc(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function _a(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof G || t2 instanceof Hu || t2 instanceof Gu || t2 instanceof gu || t2 instanceof zu);
}
function ma2(t2, e, n) {
  if (!_a(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = lu(n);
    throw s === "an object" ? e.Lc(t2 + " a custom object") : e.Lc(t2 + " " + s);
  }
}
function ga(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Qu)
    return e._internalPath;
  if (typeof e == "string")
    return pa2(t2, e);
  throw Ea("Field path arguments must be of type string or FieldPath.", t2, false, void 0, n);
}
var ya2 = new RegExp("[~\\*/\\[\\]]");
function pa2(t2, e, n) {
  if (e.search(ya2) >= 0)
    throw Ea(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new Qu(...e.split("."))._internalPath;
  } catch (s) {
    throw Ea(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function Ea(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let c = `Function ${e}() called with invalid data`;
  n && (c += " (via `toFirestore()`)"), c += ". ";
  let u = "";
  return (r || o) && (u += " (found", r && (u += ` in field ${s}`), o && (u += ` in document ${i}`), u += ")"), new C2(D2.INVALID_ARGUMENT, c + t2 + u);
}
function Ta(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var Ia2 = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new gu(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new Aa2(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(Ra2("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var Aa2 = class extends Ia2 {
  data() {
    return super.data();
  }
};
function Ra2(t2, e) {
  return typeof e == "string" ? pa2(t2, e) : e instanceof Qu ? e._internalPath : e._delegate._internalPath;
}
var Pa = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var ba2 = class extends Ia2 {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new va(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(Ra2("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var va = class extends ba2 {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var Va2 = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new Pa(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new va(this._firestore, this._userDataWriter, n.key, n, new Pa(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new C2(D2.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new va(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new Pa(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new va(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new Pa(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: Sa2(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function Sa2(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L2();
  }
}
function Da(t2, e) {
  return t2 instanceof ba2 && e instanceof ba2 ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof Va2 && e instanceof Va2 && (t2._firestore === e._firestore && Ru(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function Ca2(t2) {
  if (ie(t2) && t2.explicitOrderBy.length === 0)
    throw new C2(D2.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Na2 = class {
};
function xa2(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var ka2 = class extends Na2 {
  constructor(t2, e, n) {
    super(), this.Qc = t2, this.Wc = e, this.Gc = n, this.type = "where";
  }
  _apply(t2) {
    const e = na2(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let c;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new C2(D2.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on FieldPath.documentId().`);
        if (r === "in" || r === "not-in") {
          Ha2(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(za2(s, t3, n3));
          c = {
            arrayValue: {
              values: e3
            }
          };
        } else
          c = za2(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || Ha2(o, r), c = fa2(n2, e2, o, r === "in" || r === "not-in");
      const u = Mt.create(i, r, c);
      return function(t4, e3) {
        if (e3.g()) {
          const n4 = oe(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new C2(D2.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = re(t4);
          s2 !== null && Ja2(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new C2(D2.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new C2(D2.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, u), u;
    }(t2._query, "where", e, t2.firestore._databaseId, this.Qc, this.Wc, this.Gc);
    return new yu(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new te(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function $a2(t2, e, n) {
  const s = e, i = Ra2("where", t2);
  return new ka2(i, s, n);
}
var Oa = class extends Na2 {
  constructor(t2, e) {
    super(), this.Qc = t2, this.zc = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new C2(D2.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new C2(D2.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new Jt(e2, n);
      return function(t4, e3) {
        if (re(t4) === null) {
          const n2 = oe(t4);
          n2 !== null && Ja2(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.Qc, this.zc);
    return new yu(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new te(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function Fa2(t2, e = "asc") {
  const n = e, s = Ra2("orderBy", t2);
  return new Oa(s, n);
}
var Ma2 = class extends Na2 {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Hc = e, this.Jc = n;
  }
  _apply(t2) {
    return new yu(t2.firestore, t2.converter, he(t2._query, this.Hc, this.Jc));
  }
};
function La2(t2) {
  return du("limit", t2), new Ma2("limit", t2, "F");
}
function Ba(t2) {
  return du("limitToLast", t2), new Ma2("limitToLast", t2, "L");
}
var Ua2 = class extends Na2 {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Yc = e, this.Xc = n;
  }
  _apply(t2) {
    const e = Ga2(t2, this.type, this.Yc, this.Xc);
    return new yu(t2.firestore, t2.converter, function(t3, e2) {
      return new te(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function qa2(...t2) {
  return new Ua2("startAt", t2, true);
}
function Ka2(...t2) {
  return new Ua2("startAfter", t2, false);
}
var ja2 = class extends Na2 {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Yc = e, this.Xc = n;
  }
  _apply(t2) {
    const e = Ga2(t2, this.type, this.Yc, this.Xc);
    return new yu(t2.firestore, t2.converter, function(t3, e2) {
      return new te(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function Qa(...t2) {
  return new ja2("endBefore", t2, true);
}
function Wa2(...t2) {
  return new ja2("endAt", t2, false);
}
function Ga2(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof Ia2)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new C2(D2.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of ue(t3))
        if (n3.field.isKeyField())
          r.push(It(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (ut(t4))
            throw new C2(D2.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new C2(D2.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new zt(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = na2(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new C2(D2.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const c = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const u = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof u != "string")
            throw new C2(D2.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof u}`);
          if (!ce(t3) && u.indexOf("/") !== -1)
            throw new C2(D2.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to ${s2}() must be a plain document ID, but '${u}' contains a slash.`);
          const n3 = t3.path.child(Z2.fromString(u));
          if (!wt.isDocumentKey(n3))
            throw new C2(D2.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new wt(n3);
          c.push(It(e2, i3));
        } else {
          const t4 = fa2(n2, s2, u);
          c.push(t4);
        }
      }
      return new zt(c, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function za2(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new C2(D2.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!ce(e) && n.indexOf("/") !== -1)
      throw new C2(D2.INVALID_ARGUMENT, `Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(Z2.fromString(n));
    if (!wt.isDocumentKey(s))
      throw new C2(D2.INVALID_ARGUMENT, `Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return It(t2, new wt(s));
  }
  if (n instanceof gu)
    return It(t2, n._key);
  throw new C2(D2.INVALID_ARGUMENT, `Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: ${lu(n)}.`);
}
function Ha2(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new C2(D2.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new C2(D2.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function Ja2(t2, e, n) {
  if (!n.isEqual(e))
    throw new C2(D2.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var Ya2 = class {
  convertValue(t2, e = "none") {
    switch (_t(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return ot(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(ct(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw L2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return J2(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new Hu(ot(t2.latitude), ot(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = at(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(ht(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = rt(t2);
    return new G(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = Z2.fromString(t2);
    B2(us(n));
    const s = new tu(n.get(1), n.get(3)), i = new wt(n.popFirst(5));
    return s.isEqual(e) || O2(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function Xa2(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var Za2 = class extends Ya2 {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Gu(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new gu(this.firestore, null, e);
  }
};
var th = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = na2(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = eh(t2, this._firestore), i = Xa2(s.converter, e, n), r = sa2(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, $e.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = eh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Qu ? la2(this._dataReader, "WriteBatch.update", i._key, e, n, s) : ha2(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, $e.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = eh(t2, this._firestore);
    return this._mutations = this._mutations.concat(new ze(e._key, $e.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new C2(D2.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function eh(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new C2(D2.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function nh(t2) {
  t2 = fu(t2, gu);
  const e = fu(t2.firestore, Su);
  return Wc2(Nu(e), t2._key).then((n) => mh(e, t2, n));
}
var sh = class extends Ya2 {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Gu(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new gu(this.firestore, null, e);
  }
};
function ih(t2) {
  t2 = fu(t2, gu);
  const e = fu(t2.firestore, Su), n = Nu(e), s = new sh(e);
  return Qc2(n, t2._key).then((n2) => new ba2(e, s, t2._key, n2, new Pa(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function rh(t2) {
  t2 = fu(t2, gu);
  const e = fu(t2.firestore, Su);
  return Wc2(Nu(e), t2._key, {
    source: "server"
  }).then((n) => mh(e, t2, n));
}
function oh(t2) {
  t2 = fu(t2, yu);
  const e = fu(t2.firestore, Su), n = Nu(e), s = new sh(e);
  return Ca2(t2._query), zc2(n, t2._query).then((n2) => new Va2(e, s, t2, n2));
}
function ch(t2) {
  t2 = fu(t2, yu);
  const e = fu(t2.firestore, Su), n = Nu(e), s = new sh(e);
  return Gc2(n, t2._query).then((n2) => new Va2(e, s, t2, n2));
}
function uh(t2) {
  t2 = fu(t2, yu);
  const e = fu(t2.firestore, Su), n = Nu(e), s = new sh(e);
  return zc2(n, t2._query, {
    source: "server"
  }).then((n2) => new Va2(e, s, t2, n2));
}
function ah(t2, e, n) {
  t2 = fu(t2, gu);
  const s = fu(t2.firestore, Su), i = Xa2(t2.converter, e, n);
  return _h(s, [sa2(na2(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, $e.none())]);
}
function hh(t2, e, n, ...s) {
  t2 = fu(t2, gu);
  const i = fu(t2.firestore, Su), r = na2(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof Qu ? la2(r, "updateDoc", t2._key, e, n, s) : ha2(r, "updateDoc", t2._key, e);
  return _h(i, [o.toMutation(t2._key, $e.exists(true))]);
}
function lh(t2) {
  return _h(fu(t2.firestore, Su), [new ze(t2._key, $e.none())]);
}
function fh(t2, e) {
  const n = fu(t2.firestore, Su), s = Iu(t2), i = Xa2(t2.converter, e);
  return _h(n, [sa2(na2(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, $e.exists(false))]).then(() => s);
}
function dh(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || bu(e[o]) || (r = e[o], o++);
  const c = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (bu(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let u, a, h;
  if (t2 instanceof gu)
    a = fu(t2.firestore, Su), h = ne(t2._key.path), u = {
      next: (n2) => {
        e[o] && e[o](mh(a, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = fu(t2, yu);
    a = fu(n2.firestore, Su), h = n2._query;
    const s2 = new sh(a);
    u = {
      next: (t3) => {
        e[o] && e[o](new Va2(a, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Ca2(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new Sc2(s2), r2 = new $o(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => Do(await qc2(t3), r2)), () => {
      i2.Wo(), t3.asyncQueue.enqueueAndForget(async () => Co(await qc2(t3), r2));
    };
  }(Nu(a), h, c, u);
}
function wh(t2, e) {
  return Hc2(Nu(t2 = fu(t2, Su)), bu(e) ? e : {
    next: e
  });
}
function _h(t2, e) {
  return function(t3, e2) {
    const n = new Ns();
    return t3.asyncQueue.enqueueAndForget(async () => Ho(await Uc2(t3), e2, n)), n.promise;
  }(Nu(t2), e);
}
function mh(t2, e, n) {
  const s = n.docs.get(e._key), i = new sh(t2);
  return new ba2(t2, i, e._key, s, new Pa(n.hasPendingWrites, n.fromCache), e.converter);
}
var gh = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = na2(t2);
  }
  get(t2) {
    const e = eh(t2, this._firestore), n = new Za2(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return L2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new Ia2(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new Ia2(this._firestore, n, e._key, null, e.converter);
      throw L2();
    });
  }
  set(t2, e, n) {
    const s = eh(t2, this._firestore), i = Xa2(s.converter, e, n), r = sa2(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = eh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Qu ? la2(this._dataReader, "Transaction.update", i._key, e, n, s) : ha2(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = eh(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = eh(t2, this._firestore), n = new sh(this._firestore);
    return super.get(t2).then((t3) => new ba2(this._firestore, n, e._key, t3._document, new Pa(false, false), e.converter));
  }
};
function yh(t2, e) {
  return Jc2(Nu(t2), (n) => e(new gh(t2, n)));
}
function ph() {
  return new ia2("deleteField");
}
function Eh() {
  return new oa2("serverTimestamp");
}
function Th(...t2) {
  return new ca("arrayUnion", t2);
}
function Ih(...t2) {
  return new ua2("arrayRemove", t2);
}
function Ah(t2) {
  return new aa2("increment", t2);
}
function Rh(t2) {
  return Nu(t2 = fu(t2, Su)), new th(t2, (e) => _h(t2, e));
}
var Ph;
!function(t2) {
  V2 = t2;
}(SDK_VERSION), _registerComponent(new Component("firestore-exp", (t2, { options: e }) => {
  const n = t2.getProvider("app-exp").getImmediate(), s = new Su(n, t2.getProvider("auth-internal"));
  return e = Object.assign({
    useFetchStreams: false
  }, e), s._setSettings(e), s;
}, "PUBLIC")), registerVersion("@firebase/firestore", "0.0.900-exp.6ef484a04", Ph);
export {
  Ya2 as AbstractUserDataWriter,
  Gu as Bytes,
  Vu as CACHE_SIZE_UNLIMITED,
  pu as CollectionReference,
  gu as DocumentReference,
  ba2 as DocumentSnapshot,
  Qu as FieldPath,
  zu as FieldValue,
  Su as FirebaseFirestore,
  C2 as FirestoreError,
  Hu as GeoPoint,
  vu as LoadBundleTask,
  yu as Query,
  Na2 as QueryConstraint,
  va as QueryDocumentSnapshot,
  Va2 as QuerySnapshot,
  Pa as SnapshotMetadata,
  G as Timestamp,
  gh as Transaction,
  th as WriteBatch,
  fh as addDoc,
  Ih as arrayRemove,
  Th as arrayUnion,
  Fu as clearIndexedDbPersistence,
  Eu as collection,
  Tu as collectionGroup,
  mu as connectFirestoreEmulator,
  lh as deleteDoc,
  ph as deleteField,
  Bu as disableNetwork,
  Iu as doc,
  Wu as documentId,
  ku as enableIndexedDbPersistence,
  $u as enableMultiTabIndexedDbPersistence,
  Lu as enableNetwork,
  Wa2 as endAt,
  Qa as endBefore,
  Nu as ensureFirestoreConfigured,
  _h as executeWrite,
  nh as getDoc,
  ih as getDocFromCache,
  rh as getDocFromServer,
  oh as getDocs,
  ch as getDocsFromCache,
  uh as getDocsFromServer,
  Cu as getFirestore,
  Ah as increment,
  Du as initializeFirestore,
  La2 as limit,
  Ba as limitToLast,
  qu as loadBundle,
  Ku as namedQuery,
  dh as onSnapshot,
  wh as onSnapshotsInSync,
  Fa2 as orderBy,
  xa2 as query,
  Ru as queryEqual,
  Au as refEqual,
  yh as runTransaction,
  Eh as serverTimestamp,
  ah as setDoc,
  k2 as setLogLevel,
  Da as snapshotEqual,
  Ka2 as startAfter,
  qa2 as startAt,
  Uu as terminate,
  hh as updateDoc,
  Mu as waitForPendingWrites,
  $a2 as where,
  Rh as writeBatch
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//# sourceMappingURL=firebase_firestore.js.map
